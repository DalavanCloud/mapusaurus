function getHashParams() {
    for (var e, hashParams = {}, a = /\+/g, r = /([^!&;=<>]+)(!?[=><]?)([^&;]*)/g, d = function(s) {
        return decodeURIComponent(s.replace(a, " "));
    }, q = window.location.hash.substring(1).replace(/^!\/?/, ""); e = r.exec(q); ) hashParams[d(e[1])] = {
        values: d(e[3]),
        comparator: d(e[2])
    };
    return hashParams;
}

function updateUrlHash(params) {
    function buildHashParam(param, name) {
        hashParams.push(name + "=" + param.values);
    }
    var newHash, hashParams = [];
    _.forEach(params, buildHashParam), newHash = "&" + hashParams.join("&"), window.location.hash = newHash;
}

function addParam(paramName, values) {
    var params = getHashParams();
    params[paramName] = {}, params[paramName].values = values, params[paramName].comparator = "=", 
    updateUrlHash(params);
}

(function() {
    var root = this, previousUnderscore = root._, ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype, push = ArrayProto.push, slice = ArrayProto.slice, concat = ArrayProto.concat, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty, nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeBind = FuncProto.bind, _ = function(obj) {
        return obj instanceof _ ? obj : this instanceof _ ? void (this._wrapped = obj) : new _(obj);
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = _), 
    exports._ = _) : root._ = _, _.VERSION = "1.7.0";
    var createCallback = function(func, context, argCount) {
        if (void 0 === context) return func;
        switch (null == argCount ? 3 : argCount) {
          case 1:
            return function(value) {
                return func.call(context, value);
            };

          case 2:
            return function(value, other) {
                return func.call(context, value, other);
            };

          case 3:
            return function(value, index, collection) {
                return func.call(context, value, index, collection);
            };

          case 4:
            return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
            };
        }
        return function() {
            return func.apply(context, arguments);
        };
    };
    _.iteratee = function(value, context, argCount) {
        return null == value ? _.identity : _.isFunction(value) ? createCallback(value, context, argCount) : _.isObject(value) ? _.matches(value) : _.property(value);
    }, _.each = _.forEach = function(obj, iteratee, context) {
        if (null == obj) return obj;
        iteratee = createCallback(iteratee, context);
        var i, length = obj.length;
        if (length === +length) for (i = 0; length > i; i++) iteratee(obj[i], i, obj); else {
            var keys = _.keys(obj);
            for (i = 0, length = keys.length; length > i; i++) iteratee(obj[keys[i]], keys[i], obj);
        }
        return obj;
    }, _.map = _.collect = function(obj, iteratee, context) {
        if (null == obj) return [];
        iteratee = _.iteratee(iteratee, context);
        for (var currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length, results = Array(length), index = 0; length > index; index++) currentKey = keys ? keys[index] : index, 
        results[index] = iteratee(obj[currentKey], currentKey, obj);
        return results;
    };
    var reduceError = "Reduce of empty array with no initial value";
    _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
        null == obj && (obj = []), iteratee = createCallback(iteratee, context, 4);
        var currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length, index = 0;
        if (arguments.length < 3) {
            if (!length) throw new TypeError(reduceError);
            memo = obj[keys ? keys[index++] : index++];
        }
        for (;length > index; index++) currentKey = keys ? keys[index] : index, memo = iteratee(memo, obj[currentKey], currentKey, obj);
        return memo;
    }, _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
        null == obj && (obj = []), iteratee = createCallback(iteratee, context, 4);
        var currentKey, keys = obj.length !== +obj.length && _.keys(obj), index = (keys || obj).length;
        if (arguments.length < 3) {
            if (!index) throw new TypeError(reduceError);
            memo = obj[keys ? keys[--index] : --index];
        }
        for (;index--; ) currentKey = keys ? keys[index] : index, memo = iteratee(memo, obj[currentKey], currentKey, obj);
        return memo;
    }, _.find = _.detect = function(obj, predicate, context) {
        var result;
        return predicate = _.iteratee(predicate, context), _.some(obj, function(value, index, list) {
            return predicate(value, index, list) ? (result = value, !0) : void 0;
        }), result;
    }, _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        return null == obj ? results : (predicate = _.iteratee(predicate, context), _.each(obj, function(value, index, list) {
            predicate(value, index, list) && results.push(value);
        }), results);
    }, _.reject = function(obj, predicate, context) {
        return _.filter(obj, _.negate(_.iteratee(predicate)), context);
    }, _.every = _.all = function(obj, predicate, context) {
        if (null == obj) return !0;
        predicate = _.iteratee(predicate, context);
        var index, currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length;
        for (index = 0; length > index; index++) if (currentKey = keys ? keys[index] : index, 
        !predicate(obj[currentKey], currentKey, obj)) return !1;
        return !0;
    }, _.some = _.any = function(obj, predicate, context) {
        if (null == obj) return !1;
        predicate = _.iteratee(predicate, context);
        var index, currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length;
        for (index = 0; length > index; index++) if (currentKey = keys ? keys[index] : index, 
        predicate(obj[currentKey], currentKey, obj)) return !0;
        return !1;
    }, _.contains = _.include = function(obj, target) {
        return null == obj ? !1 : (obj.length !== +obj.length && (obj = _.values(obj)), 
        _.indexOf(obj, target) >= 0);
    }, _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2), isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
            return (isFunc ? method : value[method]).apply(value, args);
        });
    }, _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
    }, _.where = function(obj, attrs) {
        return _.filter(obj, _.matches(attrs));
    }, _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matches(attrs));
    }, _.max = function(obj, iteratee, context) {
        var value, computed, result = -1/0, lastComputed = -1/0;
        if (null == iteratee && null != obj) {
            obj = obj.length === +obj.length ? obj : _.values(obj);
            for (var i = 0, length = obj.length; length > i; i++) value = obj[i], value > result && (result = value);
        } else iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list), (computed > lastComputed || computed === -1/0 && result === -1/0) && (result = value, 
            lastComputed = computed);
        });
        return result;
    }, _.min = function(obj, iteratee, context) {
        var value, computed, result = 1/0, lastComputed = 1/0;
        if (null == iteratee && null != obj) {
            obj = obj.length === +obj.length ? obj : _.values(obj);
            for (var i = 0, length = obj.length; length > i; i++) value = obj[i], result > value && (result = value);
        } else iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index, list) {
            computed = iteratee(value, index, list), (lastComputed > computed || 1/0 === computed && 1/0 === result) && (result = value, 
            lastComputed = computed);
        });
        return result;
    }, _.shuffle = function(obj) {
        for (var rand, set = obj && obj.length === +obj.length ? obj : _.values(obj), length = set.length, shuffled = Array(length), index = 0; length > index; index++) rand = _.random(0, index), 
        rand !== index && (shuffled[index] = shuffled[rand]), shuffled[rand] = set[index];
        return shuffled;
    }, _.sample = function(obj, n, guard) {
        return null == n || guard ? (obj.length !== +obj.length && (obj = _.values(obj)), 
        obj[_.random(obj.length - 1)]) : _.shuffle(obj).slice(0, Math.max(0, n));
    }, _.sortBy = function(obj, iteratee, context) {
        return iteratee = _.iteratee(iteratee, context), _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iteratee(value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria, b = right.criteria;
            if (a !== b) {
                if (a > b || void 0 === a) return 1;
                if (b > a || void 0 === b) return -1;
            }
            return left.index - right.index;
        }), "value");
    };
    var group = function(behavior) {
        return function(obj, iteratee, context) {
            var result = {};
            return iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index) {
                var key = iteratee(value, index, obj);
                behavior(result, value, key);
            }), result;
        };
    };
    _.groupBy = group(function(result, value, key) {
        _.has(result, key) ? result[key].push(value) : result[key] = [ value ];
    }), _.indexBy = group(function(result, value, key) {
        result[key] = value;
    }), _.countBy = group(function(result, value, key) {
        _.has(result, key) ? result[key]++ : result[key] = 1;
    }), _.sortedIndex = function(array, obj, iteratee, context) {
        iteratee = _.iteratee(iteratee, context, 1);
        for (var value = iteratee(obj), low = 0, high = array.length; high > low; ) {
            var mid = low + high >>> 1;
            iteratee(array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
    }, _.toArray = function(obj) {
        return obj ? _.isArray(obj) ? slice.call(obj) : obj.length === +obj.length ? _.map(obj, _.identity) : _.values(obj) : [];
    }, _.size = function(obj) {
        return null == obj ? 0 : obj.length === +obj.length ? obj.length : _.keys(obj).length;
    }, _.partition = function(obj, predicate, context) {
        predicate = _.iteratee(predicate, context);
        var pass = [], fail = [];
        return _.each(obj, function(value, key, obj) {
            (predicate(value, key, obj) ? pass : fail).push(value);
        }), [ pass, fail ];
    }, _.first = _.head = _.take = function(array, n, guard) {
        return null == array ? void 0 : null == n || guard ? array[0] : 0 > n ? [] : slice.call(array, 0, n);
    }, _.initial = function(array, n, guard) {
        return slice.call(array, 0, Math.max(0, array.length - (null == n || guard ? 1 : n)));
    }, _.last = function(array, n, guard) {
        return null == array ? void 0 : null == n || guard ? array[array.length - 1] : slice.call(array, Math.max(array.length - n, 0));
    }, _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, null == n || guard ? 1 : n);
    }, _.compact = function(array) {
        return _.filter(array, _.identity);
    };
    var flatten = function(input, shallow, strict, output) {
        if (shallow && _.every(input, _.isArray)) return concat.apply(output, input);
        for (var i = 0, length = input.length; length > i; i++) {
            var value = input[i];
            _.isArray(value) || _.isArguments(value) ? shallow ? push.apply(output, value) : flatten(value, shallow, strict, output) : strict || output.push(value);
        }
        return output;
    };
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, !1, []);
    }, _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    }, _.uniq = _.unique = function(array, isSorted, iteratee, context) {
        if (null == array) return [];
        _.isBoolean(isSorted) || (context = iteratee, iteratee = isSorted, isSorted = !1), 
        null != iteratee && (iteratee = _.iteratee(iteratee, context));
        for (var result = [], seen = [], i = 0, length = array.length; length > i; i++) {
            var value = array[i];
            if (isSorted) i && seen === value || result.push(value), seen = value; else if (iteratee) {
                var computed = iteratee(value, i, array);
                _.indexOf(seen, computed) < 0 && (seen.push(computed), result.push(value));
            } else _.indexOf(result, value) < 0 && result.push(value);
        }
        return result;
    }, _.union = function() {
        return _.uniq(flatten(arguments, !0, !0, []));
    }, _.intersection = function(array) {
        if (null == array) return [];
        for (var result = [], argsLength = arguments.length, i = 0, length = array.length; length > i; i++) {
            var item = array[i];
            if (!_.contains(result, item)) {
                for (var j = 1; argsLength > j && _.contains(arguments[j], item); j++) ;
                j === argsLength && result.push(item);
            }
        }
        return result;
    }, _.difference = function(array) {
        var rest = flatten(slice.call(arguments, 1), !0, !0, []);
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    }, _.zip = function(array) {
        if (null == array) return [];
        for (var length = _.max(arguments, "length").length, results = Array(length), i = 0; length > i; i++) results[i] = _.pluck(arguments, i);
        return results;
    }, _.object = function(list, values) {
        if (null == list) return {};
        for (var result = {}, i = 0, length = list.length; length > i; i++) values ? result[list[i]] = values[i] : result[list[i][0]] = list[i][1];
        return result;
    }, _.indexOf = function(array, item, isSorted) {
        if (null == array) return -1;
        var i = 0, length = array.length;
        if (isSorted) {
            if ("number" != typeof isSorted) return i = _.sortedIndex(array, item), array[i] === item ? i : -1;
            i = 0 > isSorted ? Math.max(0, length + isSorted) : isSorted;
        }
        for (;length > i; i++) if (array[i] === item) return i;
        return -1;
    }, _.lastIndexOf = function(array, item, from) {
        if (null == array) return -1;
        var idx = array.length;
        for ("number" == typeof from && (idx = 0 > from ? idx + from + 1 : Math.min(idx, from + 1)); --idx >= 0; ) if (array[idx] === item) return idx;
        return -1;
    }, _.range = function(start, stop, step) {
        arguments.length <= 1 && (stop = start || 0, start = 0), step = step || 1;
        for (var length = Math.max(Math.ceil((stop - start) / step), 0), range = Array(length), idx = 0; length > idx; idx++, 
        start += step) range[idx] = start;
        return range;
    };
    var Ctor = function() {};
    _.bind = function(func, context) {
        var args, bound;
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
        return args = slice.call(arguments, 2), bound = function() {
            if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
            Ctor.prototype = func.prototype;
            var self = new Ctor();
            Ctor.prototype = null;
            var result = func.apply(self, args.concat(slice.call(arguments)));
            return _.isObject(result) ? result : self;
        };
    }, _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        return function() {
            for (var position = 0, args = boundArgs.slice(), i = 0, length = args.length; length > i; i++) args[i] === _ && (args[i] = arguments[position++]);
            for (;position < arguments.length; ) args.push(arguments[position++]);
            return func.apply(this, args);
        };
    }, _.bindAll = function(obj) {
        var i, key, length = arguments.length;
        if (1 >= length) throw new Error("bindAll must be passed function names");
        for (i = 1; length > i; i++) key = arguments[i], obj[key] = _.bind(obj[key], obj);
        return obj;
    }, _.memoize = function(func, hasher) {
        var memoize = function(key) {
            var cache = memoize.cache, address = hasher ? hasher.apply(this, arguments) : key;
            return _.has(cache, address) || (cache[address] = func.apply(this, arguments)), 
            cache[address];
        };
        return memoize.cache = {}, memoize;
    }, _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    }, _.defer = function(func) {
        return _.delay.apply(_, [ func, 1 ].concat(slice.call(arguments, 1)));
    }, _.throttle = function(func, wait, options) {
        var context, args, result, timeout = null, previous = 0;
        options || (options = {});
        var later = function() {
            previous = options.leading === !1 ? 0 : _.now(), timeout = null, result = func.apply(context, args), 
            timeout || (context = args = null);
        };
        return function() {
            var now = _.now();
            previous || options.leading !== !1 || (previous = now);
            var remaining = wait - (now - previous);
            return context = this, args = arguments, 0 >= remaining || remaining > wait ? (clearTimeout(timeout), 
            timeout = null, previous = now, result = func.apply(context, args), timeout || (context = args = null)) : timeout || options.trailing === !1 || (timeout = setTimeout(later, remaining)), 
            result;
        };
    }, _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result, later = function() {
            var last = _.now() - timestamp;
            wait > last && last > 0 ? timeout = setTimeout(later, wait - last) : (timeout = null, 
            immediate || (result = func.apply(context, args), timeout || (context = args = null)));
        };
        return function() {
            context = this, args = arguments, timestamp = _.now();
            var callNow = immediate && !timeout;
            return timeout || (timeout = setTimeout(later, wait)), callNow && (result = func.apply(context, args), 
            context = args = null), result;
        };
    }, _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
    }, _.negate = function(predicate) {
        return function() {
            return !predicate.apply(this, arguments);
        };
    }, _.compose = function() {
        var args = arguments, start = args.length - 1;
        return function() {
            for (var i = start, result = args[start].apply(this, arguments); i--; ) result = args[i].call(this, result);
            return result;
        };
    }, _.after = function(times, func) {
        return function() {
            return --times < 1 ? func.apply(this, arguments) : void 0;
        };
    }, _.before = function(times, func) {
        var memo;
        return function() {
            return --times > 0 ? memo = func.apply(this, arguments) : func = null, memo;
        };
    }, _.once = _.partial(_.before, 2), _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj) _.has(obj, key) && keys.push(key);
        return keys;
    }, _.values = function(obj) {
        for (var keys = _.keys(obj), length = keys.length, values = Array(length), i = 0; length > i; i++) values[i] = obj[keys[i]];
        return values;
    }, _.pairs = function(obj) {
        for (var keys = _.keys(obj), length = keys.length, pairs = Array(length), i = 0; length > i; i++) pairs[i] = [ keys[i], obj[keys[i]] ];
        return pairs;
    }, _.invert = function(obj) {
        for (var result = {}, keys = _.keys(obj), i = 0, length = keys.length; length > i; i++) result[obj[keys[i]]] = keys[i];
        return result;
    }, _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) _.isFunction(obj[key]) && names.push(key);
        return names.sort();
    }, _.extend = function(obj) {
        if (!_.isObject(obj)) return obj;
        for (var source, prop, i = 1, length = arguments.length; length > i; i++) {
            source = arguments[i];
            for (prop in source) hasOwnProperty.call(source, prop) && (obj[prop] = source[prop]);
        }
        return obj;
    }, _.pick = function(obj, iteratee, context) {
        var key, result = {};
        if (null == obj) return result;
        if (_.isFunction(iteratee)) {
            iteratee = createCallback(iteratee, context);
            for (key in obj) {
                var value = obj[key];
                iteratee(value, key, obj) && (result[key] = value);
            }
        } else {
            var keys = concat.apply([], slice.call(arguments, 1));
            obj = new Object(obj);
            for (var i = 0, length = keys.length; length > i; i++) key = keys[i], key in obj && (result[key] = obj[key]);
        }
        return result;
    }, _.omit = function(obj, iteratee, context) {
        if (_.isFunction(iteratee)) iteratee = _.negate(iteratee); else {
            var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
            iteratee = function(value, key) {
                return !_.contains(keys, key);
            };
        }
        return _.pick(obj, iteratee, context);
    }, _.defaults = function(obj) {
        if (!_.isObject(obj)) return obj;
        for (var i = 1, length = arguments.length; length > i; i++) {
            var source = arguments[i];
            for (var prop in source) void 0 === obj[prop] && (obj[prop] = source[prop]);
        }
        return obj;
    }, _.clone = function(obj) {
        return _.isObject(obj) ? _.isArray(obj) ? obj.slice() : _.extend({}, obj) : obj;
    }, _.tap = function(obj, interceptor) {
        return interceptor(obj), obj;
    };
    var eq = function(a, b, aStack, bStack) {
        if (a === b) return 0 !== a || 1 / a === 1 / b;
        if (null == a || null == b) return a === b;
        a instanceof _ && (a = a._wrapped), b instanceof _ && (b = b._wrapped);
        var className = toString.call(a);
        if (className !== toString.call(b)) return !1;
        switch (className) {
          case "[object RegExp]":
          case "[object String]":
            return "" + a == "" + b;

          case "[object Number]":
            return +a !== +a ? +b !== +b : 0 === +a ? 1 / +a === 1 / b : +a === +b;

          case "[object Date]":
          case "[object Boolean]":
            return +a === +b;
        }
        if ("object" != typeof a || "object" != typeof b) return !1;
        for (var length = aStack.length; length--; ) if (aStack[length] === a) return bStack[length] === b;
        var aCtor = a.constructor, bCtor = b.constructor;
        if (aCtor !== bCtor && "constructor" in a && "constructor" in b && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) return !1;
        aStack.push(a), bStack.push(b);
        var size, result;
        if ("[object Array]" === className) {
            if (size = a.length, result = size === b.length) for (;size-- && (result = eq(a[size], b[size], aStack, bStack)); ) ;
        } else {
            var key, keys = _.keys(a);
            if (size = keys.length, result = _.keys(b).length === size) for (;size-- && (key = keys[size], 
            result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)); ) ;
        }
        return aStack.pop(), bStack.pop(), result;
    };
    _.isEqual = function(a, b) {
        return eq(a, b, [], []);
    }, _.isEmpty = function(obj) {
        if (null == obj) return !0;
        if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return 0 === obj.length;
        for (var key in obj) if (_.has(obj, key)) return !1;
        return !0;
    }, _.isElement = function(obj) {
        return !(!obj || 1 !== obj.nodeType);
    }, _.isArray = nativeIsArray || function(obj) {
        return "[object Array]" === toString.call(obj);
    }, _.isObject = function(obj) {
        var type = typeof obj;
        return "function" === type || "object" === type && !!obj;
    }, _.each([ "Arguments", "Function", "String", "Number", "Date", "RegExp" ], function(name) {
        _["is" + name] = function(obj) {
            return toString.call(obj) === "[object " + name + "]";
        };
    }), _.isArguments(arguments) || (_.isArguments = function(obj) {
        return _.has(obj, "callee");
    }), "function" != typeof /./ && (_.isFunction = function(obj) {
        return "function" == typeof obj || !1;
    }), _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
    }, _.isNaN = function(obj) {
        return _.isNumber(obj) && obj !== +obj;
    }, _.isBoolean = function(obj) {
        return obj === !0 || obj === !1 || "[object Boolean]" === toString.call(obj);
    }, _.isNull = function(obj) {
        return null === obj;
    }, _.isUndefined = function(obj) {
        return void 0 === obj;
    }, _.has = function(obj, key) {
        return null != obj && hasOwnProperty.call(obj, key);
    }, _.noConflict = function() {
        return root._ = previousUnderscore, this;
    }, _.identity = function(value) {
        return value;
    }, _.constant = function(value) {
        return function() {
            return value;
        };
    }, _.noop = function() {}, _.property = function(key) {
        return function(obj) {
            return obj[key];
        };
    }, _.matches = function(attrs) {
        var pairs = _.pairs(attrs), length = pairs.length;
        return function(obj) {
            if (null == obj) return !length;
            obj = new Object(obj);
            for (var i = 0; length > i; i++) {
                var pair = pairs[i], key = pair[0];
                if (pair[1] !== obj[key] || !(key in obj)) return !1;
            }
            return !0;
        };
    }, _.times = function(n, iteratee, context) {
        var accum = Array(Math.max(0, n));
        iteratee = createCallback(iteratee, context, 1);
        for (var i = 0; n > i; i++) accum[i] = iteratee(i);
        return accum;
    }, _.random = function(min, max) {
        return null == max && (max = min, min = 0), min + Math.floor(Math.random() * (max - min + 1));
    }, _.now = Date.now || function() {
        return new Date().getTime();
    };
    var escapeMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#x27;",
        "`": "&#x60;"
    }, unescapeMap = _.invert(escapeMap), createEscaper = function(map) {
        var escaper = function(match) {
            return map[match];
        }, source = "(?:" + _.keys(map).join("|") + ")", testRegexp = RegExp(source), replaceRegexp = RegExp(source, "g");
        return function(string) {
            return string = null == string ? "" : "" + string, testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
        };
    };
    _.escape = createEscaper(escapeMap), _.unescape = createEscaper(unescapeMap), _.result = function(object, property) {
        if (null == object) return void 0;
        var value = object[property];
        return _.isFunction(value) ? object[property]() : value;
    };
    var idCounter = 0;
    _.uniqueId = function(prefix) {
        var id = ++idCounter + "";
        return prefix ? prefix + id : id;
    }, _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/, escapes = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "\u2028": "u2028",
        "\u2029": "u2029"
    }, escaper = /\\|'|\r|\n|\u2028|\u2029/g, escapeChar = function(match) {
        return "\\" + escapes[match];
    };
    _.template = function(text, settings, oldSettings) {
        !settings && oldSettings && (settings = oldSettings), settings = _.defaults({}, settings, _.templateSettings);
        var matcher = RegExp([ (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source ].join("|") + "|$", "g"), index = 0, source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            return source += text.slice(index, offset).replace(escaper, escapeChar), index = offset + match.length, 
            escape ? source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" : interpolate ? source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" : evaluate && (source += "';\n" + evaluate + "\n__p+='"), 
            match;
        }), source += "';\n", settings.variable || (source = "with(obj||{}){\n" + source + "}\n"), 
        source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
        try {
            var render = new Function(settings.variable || "obj", "_", source);
        } catch (e) {
            throw e.source = source, e;
        }
        var template = function(data) {
            return render.call(this, data, _);
        }, argument = settings.variable || "obj";
        return template.source = "function(" + argument + "){\n" + source + "}", template;
    }, _.chain = function(obj) {
        var instance = _(obj);
        return instance._chain = !0, instance;
    };
    var result = function(obj) {
        return this._chain ? _(obj).chain() : obj;
    };
    _.mixin = function(obj) {
        _.each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [ this._wrapped ];
                return push.apply(args, arguments), result.call(this, func.apply(_, args));
            };
        });
    }, _.mixin(_), _.each([ "pop", "push", "reverse", "shift", "sort", "splice", "unshift" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            return method.apply(obj, arguments), "shift" !== name && "splice" !== name || 0 !== obj.length || delete obj[0], 
            result.call(this, obj);
        };
    }), _.each([ "concat", "join", "slice" ], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result.call(this, method.apply(this._wrapped, arguments));
        };
    }), _.prototype.value = function() {
        return this._wrapped;
    }, "function" == typeof define && define.amd && define("underscore", [], function() {
        return _;
    });
}).call(this), function() {
    "use strict";
    function setup($) {
        function install(el, opts) {
            var css, themedCSS, full = el == window, msg = opts && void 0 !== opts.message ? opts.message : void 0;
            if (opts = $.extend({}, $.blockUI.defaults, opts || {}), !opts.ignoreIfBlocked || !$(el).data("blockUI.isBlocked")) {
                if (opts.overlayCSS = $.extend({}, $.blockUI.defaults.overlayCSS, opts.overlayCSS || {}), 
                css = $.extend({}, $.blockUI.defaults.css, opts.css || {}), opts.onOverlayClick && (opts.overlayCSS.cursor = "pointer"), 
                themedCSS = $.extend({}, $.blockUI.defaults.themedCSS, opts.themedCSS || {}), msg = void 0 === msg ? opts.message : msg, 
                full && pageBlock && remove(window, {
                    fadeOut: 0
                }), msg && "string" != typeof msg && (msg.parentNode || msg.jquery)) {
                    var node = msg.jquery ? msg[0] : msg, data = {};
                    $(el).data("blockUI.history", data), data.el = node, data.parent = node.parentNode, 
                    data.display = node.style.display, data.position = node.style.position, data.parent && data.parent.removeChild(node);
                }
                $(el).data("blockUI.onUnblock", opts.onUnblock);
                var lyr1, lyr2, lyr3, s, z = opts.baseZ;
                lyr1 = $(msie || opts.forceIframe ? '<iframe class="blockUI" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;position:absolute;width:100%;height:100%;top:0;left:0" src="' + opts.iframeSrc + '"></iframe>' : '<div class="blockUI" style="display:none"></div>'), 
                lyr2 = $(opts.theme ? '<div class="blockUI blockOverlay ui-widget-overlay" style="z-index:' + z++ + ';display:none"></div>' : '<div class="blockUI blockOverlay" style="z-index:' + z++ + ';display:none;border:none;margin:0;padding:0;width:100%;height:100%;top:0;left:0"></div>'), 
                opts.theme && full ? (s = '<div class="blockUI ' + opts.blockMsgClass + ' blockPage ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:fixed">', 
                opts.title && (s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>"), 
                s += '<div class="ui-widget-content ui-dialog-content"></div>', s += "</div>") : opts.theme ? (s = '<div class="blockUI ' + opts.blockMsgClass + ' blockElement ui-dialog ui-widget ui-corner-all" style="z-index:' + (z + 10) + ';display:none;position:absolute">', 
                opts.title && (s += '<div class="ui-widget-header ui-dialog-titlebar ui-corner-all blockTitle">' + (opts.title || "&nbsp;") + "</div>"), 
                s += '<div class="ui-widget-content ui-dialog-content"></div>', s += "</div>") : s = full ? '<div class="blockUI ' + opts.blockMsgClass + ' blockPage" style="z-index:' + (z + 10) + ';display:none;position:fixed"></div>' : '<div class="blockUI ' + opts.blockMsgClass + ' blockElement" style="z-index:' + (z + 10) + ';display:none;position:absolute"></div>', 
                lyr3 = $(s), msg && (opts.theme ? (lyr3.css(themedCSS), lyr3.addClass("ui-widget-content")) : lyr3.css(css)), 
                opts.theme || lyr2.css(opts.overlayCSS), lyr2.css("position", full ? "fixed" : "absolute"), 
                (msie || opts.forceIframe) && lyr1.css("opacity", 0);
                var layers = [ lyr1, lyr2, lyr3 ], $par = $(full ? "body" : el);
                $.each(layers, function() {
                    this.appendTo($par);
                }), opts.theme && opts.draggable && $.fn.draggable && lyr3.draggable({
                    handle: ".ui-dialog-titlebar",
                    cancel: "li"
                });
                var expr = setExpr && (!$.support.boxModel || $("object,embed", full ? null : el).length > 0);
                if (ie6 || expr) {
                    if (full && opts.allowBodyStretch && $.support.boxModel && $("html,body").css("height", "100%"), 
                    (ie6 || !$.support.boxModel) && !full) var t = sz(el, "borderTopWidth"), l = sz(el, "borderLeftWidth"), fixT = t ? "(0 - " + t + ")" : 0, fixL = l ? "(0 - " + l + ")" : 0;
                    $.each(layers, function(i, o) {
                        var s = o[0].style;
                        if (s.position = "absolute", 2 > i) full ? s.setExpression("height", "Math.max(document.body.scrollHeight, document.body.offsetHeight) - (jQuery.support.boxModel?0:" + opts.quirksmodeOffsetHack + ') + "px"') : s.setExpression("height", 'this.parentNode.offsetHeight + "px"'), 
                        full ? s.setExpression("width", 'jQuery.support.boxModel && document.documentElement.clientWidth || document.body.clientWidth + "px"') : s.setExpression("width", 'this.parentNode.offsetWidth + "px"'), 
                        fixL && s.setExpression("left", fixL), fixT && s.setExpression("top", fixT); else if (opts.centerY) full && s.setExpression("top", '(document.documentElement.clientHeight || document.body.clientHeight) / 2 - (this.offsetHeight / 2) + (blah = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + "px"'), 
                        s.marginTop = 0; else if (!opts.centerY && full) {
                            var top = opts.css && opts.css.top ? parseInt(opts.css.top, 10) : 0, expression = "((document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop) + " + top + ') + "px"';
                            s.setExpression("top", expression);
                        }
                    });
                }
                if (msg && (opts.theme ? lyr3.find(".ui-widget-content").append(msg) : lyr3.append(msg), 
                (msg.jquery || msg.nodeType) && $(msg).show()), (msie || opts.forceIframe) && opts.showOverlay && lyr1.show(), 
                opts.fadeIn) {
                    var cb = opts.onBlock ? opts.onBlock : noOp, cb1 = opts.showOverlay && !msg ? cb : noOp, cb2 = msg ? cb : noOp;
                    opts.showOverlay && lyr2._fadeIn(opts.fadeIn, cb1), msg && lyr3._fadeIn(opts.fadeIn, cb2);
                } else opts.showOverlay && lyr2.show(), msg && lyr3.show(), opts.onBlock && opts.onBlock.bind(lyr3)();
                if (bind(1, el, opts), full ? (pageBlock = lyr3[0], pageBlockEls = $(opts.focusableElements, pageBlock), 
                opts.focusInput && setTimeout(focus, 20)) : center(lyr3[0], opts.centerX, opts.centerY), 
                opts.timeout) {
                    var to = setTimeout(function() {
                        full ? $.unblockUI(opts) : $(el).unblock(opts);
                    }, opts.timeout);
                    $(el).data("blockUI.timeout", to);
                }
            }
        }
        function remove(el, opts) {
            var count, full = el == window, $el = $(el), data = $el.data("blockUI.history"), to = $el.data("blockUI.timeout");
            to && (clearTimeout(to), $el.removeData("blockUI.timeout")), opts = $.extend({}, $.blockUI.defaults, opts || {}), 
            bind(0, el, opts), null === opts.onUnblock && (opts.onUnblock = $el.data("blockUI.onUnblock"), 
            $el.removeData("blockUI.onUnblock"));
            var els;
            els = full ? $("body").children().filter(".blockUI").add("body > .blockUI") : $el.find(">.blockUI"), 
            opts.cursorReset && (els.length > 1 && (els[1].style.cursor = opts.cursorReset), 
            els.length > 2 && (els[2].style.cursor = opts.cursorReset)), full && (pageBlock = pageBlockEls = null), 
            opts.fadeOut ? (count = els.length, els.stop().fadeOut(opts.fadeOut, function() {
                0 === --count && reset(els, data, opts, el);
            })) : reset(els, data, opts, el);
        }
        function reset(els, data, opts, el) {
            var $el = $(el);
            if (!$el.data("blockUI.isBlocked")) {
                els.each(function() {
                    this.parentNode && this.parentNode.removeChild(this);
                }), data && data.el && (data.el.style.display = data.display, data.el.style.position = data.position, 
                data.el.style.cursor = "default", data.parent && data.parent.appendChild(data.el), 
                $el.removeData("blockUI.history")), $el.data("blockUI.static") && $el.css("position", "static"), 
                "function" == typeof opts.onUnblock && opts.onUnblock(el, opts);
                var body = $(document.body), w = body.width(), cssW = body[0].style.width;
                body.width(w - 1).width(w), body[0].style.width = cssW;
            }
        }
        function bind(b, el, opts) {
            var full = el == window, $el = $(el);
            if ((b || (!full || pageBlock) && (full || $el.data("blockUI.isBlocked"))) && ($el.data("blockUI.isBlocked", b), 
            full && opts.bindEvents && (!b || opts.showOverlay))) {
                var events = "mousedown mouseup keydown keypress keyup touchstart touchend touchmove";
                b ? $(document).bind(events, opts, handler) : $(document).unbind(events, handler);
            }
        }
        function handler(e) {
            if ("keydown" === e.type && e.keyCode && 9 == e.keyCode && pageBlock && e.data.constrainTabKey) {
                var els = pageBlockEls, fwd = !e.shiftKey && e.target === els[els.length - 1], back = e.shiftKey && e.target === els[0];
                if (fwd || back) return setTimeout(function() {
                    focus(back);
                }, 10), !1;
            }
            var opts = e.data, target = $(e.target);
            return target.hasClass("blockOverlay") && opts.onOverlayClick && opts.onOverlayClick(e), 
            target.parents("div." + opts.blockMsgClass).length > 0 ? !0 : 0 === target.parents().children().filter("div.blockUI").length;
        }
        function focus(back) {
            if (pageBlockEls) {
                var e = pageBlockEls[back === !0 ? pageBlockEls.length - 1 : 0];
                e && e.focus();
            }
        }
        function center(el, x, y) {
            var p = el.parentNode, s = el.style, l = (p.offsetWidth - el.offsetWidth) / 2 - sz(p, "borderLeftWidth"), t = (p.offsetHeight - el.offsetHeight) / 2 - sz(p, "borderTopWidth");
            x && (s.left = l > 0 ? l + "px" : "0"), y && (s.top = t > 0 ? t + "px" : "0");
        }
        function sz(el, p) {
            return parseInt($.css(el, p), 10) || 0;
        }
        $.fn._fadeIn = $.fn.fadeIn;
        var noOp = $.noop || function() {}, msie = /MSIE/.test(navigator.userAgent), ie6 = /MSIE 6.0/.test(navigator.userAgent) && !/MSIE 8.0/.test(navigator.userAgent), setExpr = (document.documentMode || 0, 
        $.isFunction(document.createElement("div").style.setExpression));
        $.blockUI = function(opts) {
            install(window, opts);
        }, $.unblockUI = function(opts) {
            remove(window, opts);
        }, $.growlUI = function(title, message, timeout, onClose) {
            var $m = $('<div class="growlUI"></div>');
            title && $m.append("<h1>" + title + "</h1>"), message && $m.append("<h2>" + message + "</h2>"), 
            void 0 === timeout && (timeout = 3e3);
            var callBlock = function(opts) {
                opts = opts || {}, $.blockUI({
                    message: $m,
                    fadeIn: "undefined" != typeof opts.fadeIn ? opts.fadeIn : 700,
                    fadeOut: "undefined" != typeof opts.fadeOut ? opts.fadeOut : 1e3,
                    timeout: "undefined" != typeof opts.timeout ? opts.timeout : timeout,
                    centerY: !1,
                    showOverlay: !1,
                    onUnblock: onClose,
                    css: $.blockUI.defaults.growlCSS
                });
            };
            callBlock();
            $m.css("opacity");
            $m.mouseover(function() {
                callBlock({
                    fadeIn: 0,
                    timeout: 3e4
                });
                var displayBlock = $(".blockMsg");
                displayBlock.stop(), displayBlock.fadeTo(300, 1);
            }).mouseout(function() {
                $(".blockMsg").fadeOut(1e3);
            });
        }, $.fn.block = function(opts) {
            if (this[0] === window) return $.blockUI(opts), this;
            var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
            return this.each(function() {
                var $el = $(this);
                fullOpts.ignoreIfBlocked && $el.data("blockUI.isBlocked") || $el.unblock({
                    fadeOut: 0
                });
            }), this.each(function() {
                "static" == $.css(this, "position") && (this.style.position = "relative", $(this).data("blockUI.static", !0)), 
                this.style.zoom = 1, install(this, opts);
            });
        }, $.fn.unblock = function(opts) {
            return this[0] === window ? ($.unblockUI(opts), this) : this.each(function() {
                remove(this, opts);
            });
        }, $.blockUI.version = 2.7, $.blockUI.defaults = {
            message: "<h1>Please wait...</h1>",
            title: null,
            draggable: !0,
            theme: !1,
            css: {
                padding: 0,
                margin: 0,
                width: "30%",
                top: "40%",
                left: "35%",
                textAlign: "center",
                color: "#000",
                border: "3px solid #aaa",
                backgroundColor: "#fff",
                cursor: "wait"
            },
            themedCSS: {
                width: "30%",
                top: "40%",
                left: "35%"
            },
            overlayCSS: {
                backgroundColor: "#000",
                opacity: .6,
                cursor: "wait"
            },
            cursorReset: "default",
            growlCSS: {
                width: "350px",
                top: "10px",
                left: "",
                right: "10px",
                border: "none",
                padding: "5px",
                opacity: .6,
                cursor: "default",
                color: "#fff",
                backgroundColor: "#000",
                "-webkit-border-radius": "10px",
                "-moz-border-radius": "10px",
                "border-radius": "10px"
            },
            iframeSrc: /^https/i.test(window.location.href || "") ? "javascript:false" : "about:blank",
            forceIframe: !1,
            baseZ: 1e3,
            centerX: !0,
            centerY: !0,
            allowBodyStretch: !0,
            bindEvents: !0,
            constrainTabKey: !0,
            fadeIn: 200,
            fadeOut: 400,
            timeout: 0,
            showOverlay: !0,
            focusInput: !0,
            focusableElements: ":input:enabled:visible",
            onBlock: null,
            onUnblock: null,
            onOverlayClick: null,
            quirksmodeOffsetHack: 4,
            blockMsgClass: "blockMsg",
            ignoreIfBlocked: !1
        };
        var pageBlock = null, pageBlockEls = [];
    }
    "function" == typeof define && define.amd && define.amd.jQuery ? define([ "jquery" ], setup) : setup(jQuery);
}(), function(a, b, c) {
    !function(a) {
        "function" == typeof define && define.amd ? define([ "jquery" ], a) : jQuery && !jQuery.fn.sparkline && a(jQuery);
    }(function(d) {
        "use strict";
        var f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, e = {}, L = 0;
        f = function() {
            return {
                common: {
                    type: "line",
                    lineColor: "#00f",
                    fillColor: "#cdf",
                    defaultPixelsPerValue: 3,
                    width: "auto",
                    height: "auto",
                    composite: !1,
                    tagValuesAttribute: "values",
                    tagOptionsPrefix: "spark",
                    enableTagOptions: !1,
                    enableHighlight: !0,
                    highlightLighten: 1.4,
                    tooltipSkipNull: !0,
                    tooltipPrefix: "",
                    tooltipSuffix: "",
                    disableHiddenCheck: !1,
                    numberFormatter: !1,
                    numberDigitGroupCount: 3,
                    numberDigitGroupSep: ",",
                    numberDecimalMark: ".",
                    disableTooltips: !1,
                    disableInteraction: !1
                },
                line: {
                    spotColor: "#f80",
                    highlightSpotColor: "#5f5",
                    highlightLineColor: "#f22",
                    spotRadius: 1.5,
                    minSpotColor: "#f80",
                    maxSpotColor: "#f80",
                    lineWidth: 1,
                    normalRangeMin: c,
                    normalRangeMax: c,
                    normalRangeColor: "#ccc",
                    drawNormalOnTop: !1,
                    chartRangeMin: c,
                    chartRangeMax: c,
                    chartRangeMinX: c,
                    chartRangeMaxX: c,
                    tooltipFormat: new h('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{y}}{{suffix}}')
                },
                bar: {
                    barColor: "#3366cc",
                    negBarColor: "#f44",
                    stackedBarColor: [ "#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099" ],
                    zeroColor: c,
                    nullColor: c,
                    zeroAxis: !0,
                    barWidth: 4,
                    barSpacing: 1,
                    chartRangeMax: c,
                    chartRangeMin: c,
                    chartRangeClip: !1,
                    colorMap: c,
                    tooltipFormat: new h('<span style="color: {{color}}">&#9679;</span> {{prefix}}{{value}}{{suffix}}')
                },
                tristate: {
                    barWidth: 4,
                    barSpacing: 1,
                    posBarColor: "#6f6",
                    negBarColor: "#f44",
                    zeroBarColor: "#999",
                    colorMap: {},
                    tooltipFormat: new h('<span style="color: {{color}}">&#9679;</span> {{value:map}}'),
                    tooltipValueLookups: {
                        map: {
                            "-1": "Loss",
                            0: "Draw",
                            1: "Win"
                        }
                    }
                },
                discrete: {
                    lineHeight: "auto",
                    thresholdColor: c,
                    thresholdValue: 0,
                    chartRangeMax: c,
                    chartRangeMin: c,
                    chartRangeClip: !1,
                    tooltipFormat: new h("{{prefix}}{{value}}{{suffix}}")
                },
                bullet: {
                    targetColor: "#f33",
                    targetWidth: 3,
                    performanceColor: "#33f",
                    rangeColors: [ "#d3dafe", "#a8b6ff", "#7f94ff" ],
                    base: c,
                    tooltipFormat: new h("{{fieldkey:fields}} - {{value}}"),
                    tooltipValueLookups: {
                        fields: {
                            r: "Range",
                            p: "Performance",
                            t: "Target"
                        }
                    }
                },
                pie: {
                    offset: 0,
                    sliceColors: [ "#3366cc", "#dc3912", "#ff9900", "#109618", "#66aa00", "#dd4477", "#0099c6", "#990099" ],
                    borderWidth: 0,
                    borderColor: "#000",
                    tooltipFormat: new h('<span style="color: {{color}}">&#9679;</span> {{value}} ({{percent.1}}%)')
                },
                box: {
                    raw: !1,
                    boxLineColor: "#000",
                    boxFillColor: "#cdf",
                    whiskerColor: "#000",
                    outlierLineColor: "#333",
                    outlierFillColor: "#fff",
                    medianColor: "#f00",
                    showOutliers: !0,
                    outlierIQR: 1.5,
                    spotRadius: 1.5,
                    target: c,
                    targetColor: "#4a2",
                    chartRangeMax: c,
                    chartRangeMin: c,
                    tooltipFormat: new h("{{field:fields}}: {{value}}"),
                    tooltipFormatFieldlistKey: "field",
                    tooltipValueLookups: {
                        fields: {
                            lq: "Lower Quartile",
                            med: "Median",
                            uq: "Upper Quartile",
                            lo: "Left Outlier",
                            ro: "Right Outlier",
                            lw: "Left Whisker",
                            rw: "Right Whisker"
                        }
                    }
                }
            };
        }, E = '.jqstooltip { position: absolute;left: 0px;top: 0px;visibility: hidden;background: rgb(0, 0, 0) transparent;background-color: rgba(0,0,0,0.6);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000);-ms-filter: "progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)";color: white;font: 10px arial, san serif;text-align: left;white-space: nowrap;padding: 5px;border: 1px solid white;z-index: 10000;}.jqsfield { color: white;font: 10px arial, san serif;text-align: left;}', 
        g = function() {
            var a, b;
            return a = function() {
                this.init.apply(this, arguments);
            }, arguments.length > 1 ? (arguments[0] ? (a.prototype = d.extend(new arguments[0](), arguments[arguments.length - 1]), 
            a._super = arguments[0].prototype) : a.prototype = arguments[arguments.length - 1], 
            arguments.length > 2 && (b = Array.prototype.slice.call(arguments, 1, -1), b.unshift(a.prototype), 
            d.extend.apply(d, b))) : a.prototype = arguments[0], a.prototype.cls = a, a;
        }, d.SPFormatClass = h = g({
            fre: /\{\{([\w.]+?)(:(.+?))?\}\}/g,
            precre: /(\w+)\.(\d+)/,
            init: function(a, b) {
                this.format = a, this.fclass = b;
            },
            render: function(a, b, d) {
                var g, h, i, j, k, e = this, f = a;
                return this.format.replace(this.fre, function() {
                    var a;
                    return h = arguments[1], i = arguments[3], g = e.precre.exec(h), g ? (k = g[2], 
                    h = g[1]) : k = !1, j = f[h], j === c ? "" : i && b && b[i] ? (a = b[i], a.get ? b[i].get(j) || j : b[i][j] || j) : (n(j) && (j = d.get("numberFormatter") ? d.get("numberFormatter")(j) : s(j, k, d.get("numberDigitGroupCount"), d.get("numberDigitGroupSep"), d.get("numberDecimalMark"))), 
                    j);
                });
            }
        }), d.spformat = function(a, b) {
            return new h(a, b);
        }, i = function(a, b, c) {
            return b > a ? b : a > c ? c : a;
        }, j = function(a, c) {
            var d;
            return 2 === c ? (d = b.floor(a.length / 2), a.length % 2 ? a[d] : (a[d - 1] + a[d]) / 2) : a.length % 2 ? (d = (a.length * c + c) / 4, 
            d % 1 ? (a[b.floor(d)] + a[b.floor(d) - 1]) / 2 : a[d - 1]) : (d = (a.length * c + 2) / 4, 
            d % 1 ? (a[b.floor(d)] + a[b.floor(d) - 1]) / 2 : a[d - 1]);
        }, k = function(a) {
            var b;
            switch (a) {
              case "undefined":
                a = c;
                break;

              case "null":
                a = null;
                break;

              case "true":
                a = !0;
                break;

              case "false":
                a = !1;
                break;

              default:
                b = parseFloat(a), a == b && (a = b);
            }
            return a;
        }, l = function(a) {
            var b, c = [];
            for (b = a.length; b--; ) c[b] = k(a[b]);
            return c;
        }, m = function(a, b) {
            var c, d, e = [];
            for (c = 0, d = a.length; d > c; c++) a[c] !== b && e.push(a[c]);
            return e;
        }, n = function(a) {
            return !isNaN(parseFloat(a)) && isFinite(a);
        }, s = function(a, b, c, e, f) {
            var g, h;
            for (a = (b === !1 ? parseFloat(a).toString() : a.toFixed(b)).split(""), g = (g = d.inArray(".", a)) < 0 ? a.length : g, 
            g < a.length && (a[g] = f), h = g - c; h > 0; h -= c) a.splice(h, 0, e);
            return a.join("");
        }, o = function(a, b, c) {
            var d;
            for (d = b.length; d--; ) if ((!c || null !== b[d]) && b[d] !== a) return !1;
            return !0;
        }, p = function(a) {
            var c, b = 0;
            for (c = a.length; c--; ) b += "number" == typeof a[c] ? a[c] : 0;
            return b;
        }, r = function(a) {
            return d.isArray(a) ? a : [ a ];
        }, q = function(b) {
            var c;
            a.createStyleSheet ? a.createStyleSheet().cssText = b : (c = a.createElement("style"), 
            c.type = "text/css", a.getElementsByTagName("head")[0].appendChild(c), c["string" == typeof a.body.style.WebkitAppearance ? "innerText" : "innerHTML"] = b);
        }, d.fn.simpledraw = function(b, e, f, g) {
            var h, i;
            if (f && (h = this.data("_jqs_vcanvas"))) return h;
            if (d.fn.sparkline.canvas === !1) return !1;
            if (d.fn.sparkline.canvas === c) {
                var j = a.createElement("canvas");
                if (j.getContext && j.getContext("2d")) d.fn.sparkline.canvas = function(a, b, c, d) {
                    return new I(a, b, c, d);
                }; else {
                    if (!a.namespaces || a.namespaces.v) return d.fn.sparkline.canvas = !1, !1;
                    a.namespaces.add("v", "urn:schemas-microsoft-com:vml", "#default#VML"), d.fn.sparkline.canvas = function(a, b, c) {
                        return new J(a, b, c);
                    };
                }
            }
            return b === c && (b = d(this).innerWidth()), e === c && (e = d(this).innerHeight()), 
            h = d.fn.sparkline.canvas(b, e, this, g), i = d(this).data("_jqs_mhandler"), i && i.registerCanvas(h), 
            h;
        }, d.fn.cleardraw = function() {
            var a = this.data("_jqs_vcanvas");
            a && a.reset();
        }, d.RangeMapClass = t = g({
            init: function(a) {
                var b, c, d = [];
                for (b in a) a.hasOwnProperty(b) && "string" == typeof b && b.indexOf(":") > -1 && (c = b.split(":"), 
                c[0] = 0 === c[0].length ? -1/0 : parseFloat(c[0]), c[1] = 0 === c[1].length ? 1/0 : parseFloat(c[1]), 
                c[2] = a[b], d.push(c));
                this.map = a, this.rangelist = d || !1;
            },
            get: function(a) {
                var d, e, f, b = this.rangelist;
                if ((f = this.map[a]) !== c) return f;
                if (b) for (d = b.length; d--; ) if (e = b[d], e[0] <= a && e[1] >= a) return e[2];
                return c;
            }
        }), d.range_map = function(a) {
            return new t(a);
        }, u = g({
            init: function(a, b) {
                var c = d(a);
                this.$el = c, this.options = b, this.currentPageX = 0, this.currentPageY = 0, this.el = a, 
                this.splist = [], this.tooltip = null, this.over = !1, this.displayTooltips = !b.get("disableTooltips"), 
                this.highlightEnabled = !b.get("disableHighlight");
            },
            registerSparkline: function(a) {
                this.splist.push(a), this.over && this.updateDisplay();
            },
            registerCanvas: function(a) {
                var b = d(a.canvas);
                this.canvas = a, this.$canvas = b, b.mouseenter(d.proxy(this.mouseenter, this)), 
                b.mouseleave(d.proxy(this.mouseleave, this)), b.click(d.proxy(this.mouseclick, this));
            },
            reset: function(a) {
                this.splist = [], this.tooltip && a && (this.tooltip.remove(), this.tooltip = c);
            },
            mouseclick: function(a) {
                var b = d.Event("sparklineClick");
                b.originalEvent = a, b.sparklines = this.splist, this.$el.trigger(b);
            },
            mouseenter: function(b) {
                d(a.body).unbind("mousemove.jqs"), d(a.body).bind("mousemove.jqs", d.proxy(this.mousemove, this)), 
                this.over = !0, this.currentPageX = b.pageX, this.currentPageY = b.pageY, this.currentEl = b.target, 
                !this.tooltip && this.displayTooltips && (this.tooltip = new v(this.options), this.tooltip.updatePosition(b.pageX, b.pageY)), 
                this.updateDisplay();
            },
            mouseleave: function() {
                d(a.body).unbind("mousemove.jqs");
                var f, g, b = this.splist, c = b.length, e = !1;
                for (this.over = !1, this.currentEl = null, this.tooltip && (this.tooltip.remove(), 
                this.tooltip = null), g = 0; c > g; g++) f = b[g], f.clearRegionHighlight() && (e = !0);
                e && this.canvas.render();
            },
            mousemove: function(a) {
                this.currentPageX = a.pageX, this.currentPageY = a.pageY, this.currentEl = a.target, 
                this.tooltip && this.tooltip.updatePosition(a.pageX, a.pageY), this.updateDisplay();
            },
            updateDisplay: function() {
                var h, i, j, k, l, a = this.splist, b = a.length, c = !1, e = this.$canvas.offset(), f = this.currentPageX - e.left, g = this.currentPageY - e.top;
                if (this.over) {
                    for (j = 0; b > j; j++) i = a[j], k = i.setRegionHighlight(this.currentEl, f, g), 
                    k && (c = !0);
                    if (c) {
                        if (l = d.Event("sparklineRegionChange"), l.sparklines = this.splist, this.$el.trigger(l), 
                        this.tooltip) {
                            for (h = "", j = 0; b > j; j++) i = a[j], h += i.getCurrentRegionTooltip();
                            this.tooltip.setContent(h);
                        }
                        this.disableHighlight || this.canvas.render();
                    }
                    null === k && this.mouseleave();
                }
            }
        }), v = g({
            sizeStyle: "position: static !important;display: block !important;visibility: hidden !important;float: left !important;",
            init: function(b) {
                var f, c = b.get("tooltipClassname", "jqstooltip"), e = this.sizeStyle;
                this.container = b.get("tooltipContainer") || a.body, this.tooltipOffsetX = b.get("tooltipOffsetX", 10), 
                this.tooltipOffsetY = b.get("tooltipOffsetY", 12), d("#jqssizetip").remove(), d("#jqstooltip").remove(), 
                this.sizetip = d("<div/>", {
                    id: "jqssizetip",
                    style: e,
                    "class": c
                }), this.tooltip = d("<div/>", {
                    id: "jqstooltip",
                    "class": c
                }).appendTo(this.container), f = this.tooltip.offset(), this.offsetLeft = f.left, 
                this.offsetTop = f.top, this.hidden = !0, d(window).unbind("resize.jqs scroll.jqs"), 
                d(window).bind("resize.jqs scroll.jqs", d.proxy(this.updateWindowDims, this)), this.updateWindowDims();
            },
            updateWindowDims: function() {
                this.scrollTop = d(window).scrollTop(), this.scrollLeft = d(window).scrollLeft(), 
                this.scrollRight = this.scrollLeft + d(window).width(), this.updatePosition();
            },
            getSize: function(a) {
                this.sizetip.html(a).appendTo(this.container), this.width = this.sizetip.width() + 1, 
                this.height = this.sizetip.height(), this.sizetip.remove();
            },
            setContent: function(a) {
                return a ? (this.getSize(a), this.tooltip.html(a).css({
                    width: this.width,
                    height: this.height,
                    visibility: "visible"
                }), this.hidden && (this.hidden = !1, this.updatePosition()), void 0) : (this.tooltip.css("visibility", "hidden"), 
                void (this.hidden = !0));
            },
            updatePosition: function(a, b) {
                if (a === c) {
                    if (this.mousex === c) return;
                    a = this.mousex - this.offsetLeft, b = this.mousey - this.offsetTop;
                } else this.mousex = a -= this.offsetLeft, this.mousey = b -= this.offsetTop;
                this.height && this.width && !this.hidden && (b -= this.height + this.tooltipOffsetY, 
                a += this.tooltipOffsetX, b < this.scrollTop && (b = this.scrollTop), a < this.scrollLeft ? a = this.scrollLeft : a + this.width > this.scrollRight && (a = this.scrollRight - this.width), 
                this.tooltip.css({
                    left: a,
                    top: b
                }));
            },
            remove: function() {
                this.tooltip.remove(), this.sizetip.remove(), this.sizetip = this.tooltip = c, d(window).unbind("resize.jqs scroll.jqs");
            }
        }), F = function() {
            q(E);
        }, d(F), K = [], d.fn.sparkline = function(b, e) {
            return this.each(function() {
                var h, i, f = new d.fn.sparkline.options(this, e), g = d(this);
                if (h = function() {
                    var e, h, i, j, k, l, m;
                    return "html" === b || b === c ? (m = this.getAttribute(f.get("tagValuesAttribute")), 
                    (m === c || null === m) && (m = g.html()), e = m.replace(/(^\s*<!--)|(-->\s*$)|\s+/g, "").split(",")) : e = b, 
                    h = "auto" === f.get("width") ? e.length * f.get("defaultPixelsPerValue") : f.get("width"), 
                    "auto" === f.get("height") ? f.get("composite") && d.data(this, "_jqs_vcanvas") || (j = a.createElement("span"), 
                    j.innerHTML = "a", g.html(j), i = d(j).innerHeight() || d(j).height(), d(j).remove(), 
                    j = null) : i = f.get("height"), f.get("disableInteraction") ? k = !1 : (k = d.data(this, "_jqs_mhandler"), 
                    k ? f.get("composite") || k.reset() : (k = new u(this, f), d.data(this, "_jqs_mhandler", k))), 
                    f.get("composite") && !d.data(this, "_jqs_vcanvas") ? void (d.data(this, "_jqs_errnotify") || (alert("Attempted to attach a composite sparkline to an element with no existing sparkline"), 
                    d.data(this, "_jqs_errnotify", !0))) : (l = new (d.fn.sparkline[f.get("type")])(this, e, f, h, i), 
                    l.render(), k && k.registerSparkline(l), void 0);
                }, d(this).html() && !f.get("disableHiddenCheck") && d(this).is(":hidden") || !d(this).parents("body").length) {
                    if (!f.get("composite") && d.data(this, "_jqs_pending")) for (i = K.length; i; i--) K[i - 1][0] == this && K.splice(i - 1, 1);
                    K.push([ this, h ]), d.data(this, "_jqs_pending", !0);
                } else h.call(this);
            });
        }, d.fn.sparkline.defaults = f(), d.sparkline_display_visible = function() {
            var a, b, c, e = [];
            for (b = 0, c = K.length; c > b; b++) a = K[b][0], d(a).is(":visible") && !d(a).parents().is(":hidden") ? (K[b][1].call(a), 
            d.data(K[b][0], "_jqs_pending", !1), e.push(b)) : !d(a).closest("html").length && !d.data(a, "_jqs_pending") && (d.data(K[b][0], "_jqs_pending", !1), 
            e.push(b));
            for (b = e.length; b; b--) K.splice(e[b - 1], 1);
        }, d.fn.sparkline.options = g({
            init: function(a, b) {
                var c, f, g, h;
                this.userOptions = b = b || {}, this.tag = a, this.tagValCache = {}, f = d.fn.sparkline.defaults, 
                g = f.common, this.tagOptionsPrefix = b.enableTagOptions && (b.tagOptionsPrefix || g.tagOptionsPrefix), 
                h = this.getTagSetting("type"), c = h === e ? f[b.type || g.type] : f[h], this.mergedOptions = d.extend({}, g, c, b);
            },
            getTagSetting: function(a) {
                var d, f, g, h, b = this.tagOptionsPrefix;
                if (b === !1 || b === c) return e;
                if (this.tagValCache.hasOwnProperty(a)) d = this.tagValCache.key; else {
                    if (d = this.tag.getAttribute(b + a), d === c || null === d) d = e; else if ("[" === d.substr(0, 1)) for (d = d.substr(1, d.length - 2).split(","), 
                    f = d.length; f--; ) d[f] = k(d[f].replace(/(^\s*)|(\s*$)/g, "")); else if ("{" === d.substr(0, 1)) for (g = d.substr(1, d.length - 2).split(","), 
                    d = {}, f = g.length; f--; ) h = g[f].split(":", 2), d[h[0].replace(/(^\s*)|(\s*$)/g, "")] = k(h[1].replace(/(^\s*)|(\s*$)/g, "")); else d = k(d);
                    this.tagValCache.key = d;
                }
                return d;
            },
            get: function(a, b) {
                var f, d = this.getTagSetting(a);
                return d !== e ? d : (f = this.mergedOptions[a]) === c ? b : f;
            }
        }), d.fn.sparkline._base = g({
            disabled: !1,
            init: function(a, b, e, f, g) {
                this.el = a, this.$el = d(a), this.values = b, this.options = e, this.width = f, 
                this.height = g, this.currentRegion = c;
            },
            initTarget: function() {
                var a = !this.options.get("disableInteraction");
                (this.target = this.$el.simpledraw(this.width, this.height, this.options.get("composite"), a)) ? (this.canvasWidth = this.target.pixelWidth, 
                this.canvasHeight = this.target.pixelHeight) : this.disabled = !0;
            },
            render: function() {
                return this.disabled ? (this.el.innerHTML = "", !1) : !0;
            },
            getRegion: function() {},
            setRegionHighlight: function(a, b, d) {
                var g, e = this.currentRegion, f = !this.options.get("disableHighlight");
                return b > this.canvasWidth || d > this.canvasHeight || 0 > b || 0 > d ? null : (g = this.getRegion(a, b, d), 
                e !== g ? (e !== c && f && this.removeHighlight(), this.currentRegion = g, g !== c && f && this.renderHighlight(), 
                !0) : !1);
            },
            clearRegionHighlight: function() {
                return this.currentRegion !== c ? (this.removeHighlight(), this.currentRegion = c, 
                !0) : !1;
            },
            renderHighlight: function() {
                this.changeHighlight(!0);
            },
            removeHighlight: function() {
                this.changeHighlight(!1);
            },
            changeHighlight: function() {},
            getCurrentRegionTooltip: function() {
                var f, g, i, j, k, l, m, n, o, p, q, r, s, t, a = this.options, b = "", e = [];
                if (this.currentRegion === c) return "";
                if (f = this.getCurrentRegionFields(), q = a.get("tooltipFormatter")) return q(this, a, f);
                if (a.get("tooltipChartTitle") && (b += '<div class="jqs jqstitle">' + a.get("tooltipChartTitle") + "</div>\n"), 
                g = this.options.get("tooltipFormat"), !g) return "";
                if (d.isArray(g) || (g = [ g ]), d.isArray(f) || (f = [ f ]), m = this.options.get("tooltipFormatFieldlist"), 
                n = this.options.get("tooltipFormatFieldlistKey"), m && n) {
                    for (o = [], l = f.length; l--; ) p = f[l][n], -1 != (t = d.inArray(p, m)) && (o[t] = f[l]);
                    f = o;
                }
                for (i = g.length, s = f.length, l = 0; i > l; l++) for (r = g[l], "string" == typeof r && (r = new h(r)), 
                j = r.fclass || "jqsfield", t = 0; s > t; t++) f[t].isNull && a.get("tooltipSkipNull") || (d.extend(f[t], {
                    prefix: a.get("tooltipPrefix"),
                    suffix: a.get("tooltipSuffix")
                }), k = r.render(f[t], a.get("tooltipValueLookups"), a), e.push('<div class="' + j + '">' + k + "</div>"));
                return e.length ? b + e.join("\n") : "";
            },
            getCurrentRegionFields: function() {},
            calcHighlightColor: function(a, c) {
                var f, g, h, j, d = c.get("highlightColor"), e = c.get("highlightLighten");
                if (d) return d;
                if (e && (f = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a) || /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(a))) {
                    for (h = [], g = 4 === a.length ? 16 : 1, j = 0; 3 > j; j++) h[j] = i(b.round(parseInt(f[j + 1], 16) * g * e), 0, 255);
                    return "rgb(" + h.join(",") + ")";
                }
                return a;
            }
        }), w = {
            changeHighlight: function(a) {
                var f, b = this.currentRegion, c = this.target, e = this.regionShapes[b];
                e && (f = this.renderRegion(b, a), d.isArray(f) || d.isArray(e) ? (c.replaceWithShapes(e, f), 
                this.regionShapes[b] = d.map(f, function(a) {
                    return a.id;
                })) : (c.replaceWithShape(e, f), this.regionShapes[b] = f.id));
            },
            render: function() {
                var e, f, g, h, a = this.values, b = this.target, c = this.regionShapes;
                if (this.cls._super.render.call(this)) {
                    for (g = a.length; g--; ) if (e = this.renderRegion(g)) if (d.isArray(e)) {
                        for (f = [], h = e.length; h--; ) e[h].append(), f.push(e[h].id);
                        c[g] = f;
                    } else e.append(), c[g] = e.id; else c[g] = null;
                    b.render();
                }
            }
        }, d.fn.sparkline.line = x = g(d.fn.sparkline._base, {
            type: "line",
            init: function(a, b, c, d, e) {
                x._super.init.call(this, a, b, c, d, e), this.vertices = [], this.regionMap = [], 
                this.xvalues = [], this.yvalues = [], this.yminmax = [], this.hightlightSpotId = null, 
                this.lastShapeId = null, this.initTarget();
            },
            getRegion: function(a, b) {
                var e, f = this.regionMap;
                for (e = f.length; e--; ) if (null !== f[e] && b >= f[e][0] && b <= f[e][1]) return f[e][2];
                return c;
            },
            getCurrentRegionFields: function() {
                var a = this.currentRegion;
                return {
                    isNull: null === this.yvalues[a],
                    x: this.xvalues[a],
                    y: this.yvalues[a],
                    color: this.options.get("lineColor"),
                    fillColor: this.options.get("fillColor"),
                    offset: a
                };
            },
            renderHighlight: function() {
                var i, j, a = this.currentRegion, b = this.target, d = this.vertices[a], e = this.options, f = e.get("spotRadius"), g = e.get("highlightSpotColor"), h = e.get("highlightLineColor");
                d && (f && g && (i = b.drawCircle(d[0], d[1], f, c, g), this.highlightSpotId = i.id, 
                b.insertAfterShape(this.lastShapeId, i)), h && (j = b.drawLine(d[0], this.canvasTop, d[0], this.canvasTop + this.canvasHeight, h), 
                this.highlightLineId = j.id, b.insertAfterShape(this.lastShapeId, j)));
            },
            removeHighlight: function() {
                var a = this.target;
                this.highlightSpotId && (a.removeShapeId(this.highlightSpotId), this.highlightSpotId = null), 
                this.highlightLineId && (a.removeShapeId(this.highlightLineId), this.highlightLineId = null);
            },
            scanValues: function() {
                var g, h, i, j, k, a = this.values, c = a.length, d = this.xvalues, e = this.yvalues, f = this.yminmax;
                for (g = 0; c > g; g++) h = a[g], i = "string" == typeof a[g], j = "object" == typeof a[g] && a[g] instanceof Array, 
                k = i && a[g].split(":"), i && 2 === k.length ? (d.push(Number(k[0])), e.push(Number(k[1])), 
                f.push(Number(k[1]))) : j ? (d.push(h[0]), e.push(h[1]), f.push(h[1])) : (d.push(g), 
                null === a[g] || "null" === a[g] ? e.push(null) : (e.push(Number(h)), f.push(Number(h))));
                this.options.get("xvalues") && (d = this.options.get("xvalues")), this.maxy = this.maxyorg = b.max.apply(b, f), 
                this.miny = this.minyorg = b.min.apply(b, f), this.maxx = b.max.apply(b, d), this.minx = b.min.apply(b, d), 
                this.xvalues = d, this.yvalues = e, this.yminmax = f;
            },
            processRangeOptions: function() {
                var a = this.options, b = a.get("normalRangeMin"), d = a.get("normalRangeMax");
                b !== c && (b < this.miny && (this.miny = b), d > this.maxy && (this.maxy = d)), 
                a.get("chartRangeMin") !== c && (a.get("chartRangeClip") || a.get("chartRangeMin") < this.miny) && (this.miny = a.get("chartRangeMin")), 
                a.get("chartRangeMax") !== c && (a.get("chartRangeClip") || a.get("chartRangeMax") > this.maxy) && (this.maxy = a.get("chartRangeMax")), 
                a.get("chartRangeMinX") !== c && (a.get("chartRangeClipX") || a.get("chartRangeMinX") < this.minx) && (this.minx = a.get("chartRangeMinX")), 
                a.get("chartRangeMaxX") !== c && (a.get("chartRangeClipX") || a.get("chartRangeMaxX") > this.maxx) && (this.maxx = a.get("chartRangeMaxX"));
            },
            drawNormalRange: function(a, d, e, f, g) {
                var h = this.options.get("normalRangeMin"), i = this.options.get("normalRangeMax"), j = d + b.round(e - e * ((i - this.miny) / g)), k = b.round(e * (i - h) / g);
                this.target.drawRect(a, j, f, k, c, this.options.get("normalRangeColor")).append();
            },
            render: function() {
                var k, l, m, n, o, p, q, r, s, u, v, w, y, z, A, B, C, D, E, F, G, H, I, J, K, a = this.options, e = this.target, f = this.canvasWidth, g = this.canvasHeight, h = this.vertices, i = a.get("spotRadius"), j = this.regionMap;
                if (x._super.render.call(this) && (this.scanValues(), this.processRangeOptions(), 
                I = this.xvalues, J = this.yvalues, this.yminmax.length && !(this.yvalues.length < 2))) {
                    for (n = o = 0, k = this.maxx - this.minx === 0 ? 1 : this.maxx - this.minx, l = this.maxy - this.miny === 0 ? 1 : this.maxy - this.miny, 
                    m = this.yvalues.length - 1, i && (4 * i > f || 4 * i > g) && (i = 0), i && (G = a.get("highlightSpotColor") && !a.get("disableInteraction"), 
                    (G || a.get("minSpotColor") || a.get("spotColor") && J[m] === this.miny) && (g -= b.ceil(i)), 
                    (G || a.get("maxSpotColor") || a.get("spotColor") && J[m] === this.maxy) && (g -= b.ceil(i), 
                    n += b.ceil(i)), (G || (a.get("minSpotColor") || a.get("maxSpotColor")) && (J[0] === this.miny || J[0] === this.maxy)) && (o += b.ceil(i), 
                    f -= b.ceil(i)), (G || a.get("spotColor") || a.get("minSpotColor") || a.get("maxSpotColor") && (J[m] === this.miny || J[m] === this.maxy)) && (f -= b.ceil(i))), 
                    g--, a.get("normalRangeMin") !== c && !a.get("drawNormalOnTop") && this.drawNormalRange(o, n, g, f, l), 
                    q = [], r = [ q ], z = A = null, B = J.length, K = 0; B > K; K++) s = I[K], v = I[K + 1], 
                    u = J[K], w = o + b.round((s - this.minx) * (f / k)), y = B - 1 > K ? o + b.round((v - this.minx) * (f / k)) : f, 
                    A = w + (y - w) / 2, j[K] = [ z || 0, A, K ], z = A, null === u ? K && (null !== J[K - 1] && (q = [], 
                    r.push(q)), h.push(null)) : (u < this.miny && (u = this.miny), u > this.maxy && (u = this.maxy), 
                    q.length || q.push([ w, n + g ]), p = [ w, n + b.round(g - g * ((u - this.miny) / l)) ], 
                    q.push(p), h.push(p));
                    for (C = [], D = [], E = r.length, K = 0; E > K; K++) q = r[K], q.length && (a.get("fillColor") && (q.push([ q[q.length - 1][0], n + g ]), 
                    D.push(q.slice(0)), q.pop()), q.length > 2 && (q[0] = [ q[0][0], q[1][1] ]), C.push(q));
                    for (E = D.length, K = 0; E > K; K++) e.drawShape(D[K], a.get("fillColor"), a.get("fillColor")).append();
                    for (a.get("normalRangeMin") !== c && a.get("drawNormalOnTop") && this.drawNormalRange(o, n, g, f, l), 
                    E = C.length, K = 0; E > K; K++) e.drawShape(C[K], a.get("lineColor"), c, a.get("lineWidth")).append();
                    if (i && a.get("valueSpots")) for (F = a.get("valueSpots"), F.get === c && (F = new t(F)), 
                    K = 0; B > K; K++) H = F.get(J[K]), H && e.drawCircle(o + b.round((I[K] - this.minx) * (f / k)), n + b.round(g - g * ((J[K] - this.miny) / l)), i, c, H).append();
                    i && a.get("spotColor") && null !== J[m] && e.drawCircle(o + b.round((I[I.length - 1] - this.minx) * (f / k)), n + b.round(g - g * ((J[m] - this.miny) / l)), i, c, a.get("spotColor")).append(), 
                    this.maxy !== this.minyorg && (i && a.get("minSpotColor") && (s = I[d.inArray(this.minyorg, J)], 
                    e.drawCircle(o + b.round((s - this.minx) * (f / k)), n + b.round(g - g * ((this.minyorg - this.miny) / l)), i, c, a.get("minSpotColor")).append()), 
                    i && a.get("maxSpotColor") && (s = I[d.inArray(this.maxyorg, J)], e.drawCircle(o + b.round((s - this.minx) * (f / k)), n + b.round(g - g * ((this.maxyorg - this.miny) / l)), i, c, a.get("maxSpotColor")).append())), 
                    this.lastShapeId = e.getLastShapeId(), this.canvasTop = n, e.render();
                }
            }
        }), d.fn.sparkline.bar = y = g(d.fn.sparkline._base, w, {
            type: "bar",
            init: function(a, e, f, g, h) {
                var u, v, w, x, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, j = parseInt(f.get("barWidth"), 10), n = parseInt(f.get("barSpacing"), 10), o = f.get("chartRangeMin"), p = f.get("chartRangeMax"), q = f.get("chartRangeClip"), r = 1/0, s = -1/0;
                for (y._super.init.call(this, a, e, f, g, h), A = 0, B = e.length; B > A; A++) O = e[A], 
                u = "string" == typeof O && O.indexOf(":") > -1, (u || d.isArray(O)) && (J = !0, 
                u && (O = e[A] = l(O.split(":"))), O = m(O, null), v = b.min.apply(b, O), w = b.max.apply(b, O), 
                r > v && (r = v), w > s && (s = w));
                this.stacked = J, this.regionShapes = {}, this.barWidth = j, this.barSpacing = n, 
                this.totalBarWidth = j + n, this.width = g = e.length * j + (e.length - 1) * n, 
                this.initTarget(), q && (H = o === c ? -1/0 : o, I = p === c ? 1/0 : p), z = [], 
                x = J ? [] : z;
                var S = [], T = [];
                for (A = 0, B = e.length; B > A; A++) if (J) for (K = e[A], e[A] = N = [], S[A] = 0, 
                x[A] = T[A] = 0, L = 0, M = K.length; M > L; L++) O = N[L] = q ? i(K[L], H, I) : K[L], 
                null !== O && (O > 0 && (S[A] += O), 0 > r && s > 0 ? 0 > O ? T[A] += b.abs(O) : x[A] += O : x[A] += b.abs(O - (0 > O ? s : r)), 
                z.push(O)); else O = q ? i(e[A], H, I) : e[A], O = e[A] = k(O), null !== O && z.push(O);
                this.max = G = b.max.apply(b, z), this.min = F = b.min.apply(b, z), this.stackMax = s = J ? b.max.apply(b, S) : G, 
                this.stackMin = r = J ? b.min.apply(b, z) : F, f.get("chartRangeMin") !== c && (f.get("chartRangeClip") || f.get("chartRangeMin") < F) && (F = f.get("chartRangeMin")), 
                f.get("chartRangeMax") !== c && (f.get("chartRangeClip") || f.get("chartRangeMax") > G) && (G = f.get("chartRangeMax")), 
                this.zeroAxis = D = f.get("zeroAxis", !0), E = 0 >= F && G >= 0 && D ? 0 : 0 == D ? F : F > 0 ? F : G, 
                this.xaxisOffset = E, C = J ? b.max.apply(b, x) + b.max.apply(b, T) : G - F, this.canvasHeightEf = D && 0 > F ? this.canvasHeight - 2 : this.canvasHeight - 1, 
                E > F ? (Q = J && G >= 0 ? s : G, P = (Q - E) / C * this.canvasHeight, P !== b.ceil(P) && (this.canvasHeightEf -= 2, 
                P = b.ceil(P))) : P = this.canvasHeight, this.yoffset = P, d.isArray(f.get("colorMap")) ? (this.colorMapByIndex = f.get("colorMap"), 
                this.colorMapByValue = null) : (this.colorMapByIndex = null, this.colorMapByValue = f.get("colorMap"), 
                this.colorMapByValue && this.colorMapByValue.get === c && (this.colorMapByValue = new t(this.colorMapByValue))), 
                this.range = C;
            },
            getRegion: function(a, d) {
                var f = b.floor(d / this.totalBarWidth);
                return 0 > f || f >= this.values.length ? c : f;
            },
            getCurrentRegionFields: function() {
                var d, e, a = this.currentRegion, b = r(this.values[a]), c = [];
                for (e = b.length; e--; ) d = b[e], c.push({
                    isNull: null === d,
                    value: d,
                    color: this.calcColor(e, d, a),
                    offset: a
                });
                return c;
            },
            calcColor: function(a, b, e) {
                var i, j, f = this.colorMapByIndex, g = this.colorMapByValue, h = this.options;
                return i = h.get(this.stacked ? "stackedBarColor" : 0 > b ? "negBarColor" : "barColor"), 
                0 === b && h.get("zeroColor") !== c && (i = h.get("zeroColor")), g && (j = g.get(b)) ? i = j : f && f.length > e && (i = f[e]), 
                d.isArray(i) ? i[a % i.length] : i;
            },
            renderRegion: function(a, e) {
                var q, r, s, t, u, v, w, x, y, z, f = this.values[a], g = this.options, h = this.xaxisOffset, i = [], j = this.range, k = this.stacked, l = this.target, m = a * this.totalBarWidth, n = this.canvasHeightEf, p = this.yoffset;
                if (f = d.isArray(f) ? f : [ f ], w = f.length, x = f[0], t = o(null, f), z = o(h, f, !0), 
                t) return g.get("nullColor") ? (s = e ? g.get("nullColor") : this.calcHighlightColor(g.get("nullColor"), g), 
                q = p > 0 ? p - 1 : p, l.drawRect(m, q, this.barWidth - 1, 0, s, s)) : c;
                for (u = p, v = 0; w > v; v++) {
                    if (x = f[v], k && x === h) {
                        if (!z || y) continue;
                        y = !0;
                    }
                    r = j > 0 ? b.floor(n * (b.abs(x - h) / j)) + 1 : 1, h > x || x === h && 0 === p ? (q = u, 
                    u += r) : (q = p - r, p -= r), s = this.calcColor(v, x, a), e && (s = this.calcHighlightColor(s, g)), 
                    i.push(l.drawRect(m, q, this.barWidth - 1, r - 1, s, s));
                }
                return 1 === i.length ? i[0] : i;
            }
        }), d.fn.sparkline.tristate = z = g(d.fn.sparkline._base, w, {
            type: "tristate",
            init: function(a, b, e, f, g) {
                var h = parseInt(e.get("barWidth"), 10), i = parseInt(e.get("barSpacing"), 10);
                z._super.init.call(this, a, b, e, f, g), this.regionShapes = {}, this.barWidth = h, 
                this.barSpacing = i, this.totalBarWidth = h + i, this.values = d.map(b, Number), 
                this.width = f = b.length * h + (b.length - 1) * i, d.isArray(e.get("colorMap")) ? (this.colorMapByIndex = e.get("colorMap"), 
                this.colorMapByValue = null) : (this.colorMapByIndex = null, this.colorMapByValue = e.get("colorMap"), 
                this.colorMapByValue && this.colorMapByValue.get === c && (this.colorMapByValue = new t(this.colorMapByValue))), 
                this.initTarget();
            },
            getRegion: function(a, c) {
                return b.floor(c / this.totalBarWidth);
            },
            getCurrentRegionFields: function() {
                var a = this.currentRegion;
                return {
                    isNull: this.values[a] === c,
                    value: this.values[a],
                    color: this.calcColor(this.values[a], a),
                    offset: a
                };
            },
            calcColor: function(a, b) {
                var g, h, c = this.values, d = this.options, e = this.colorMapByIndex, f = this.colorMapByValue;
                return g = f && (h = f.get(a)) ? h : e && e.length > b ? e[b] : d.get(c[b] < 0 ? "negBarColor" : c[b] > 0 ? "posBarColor" : "zeroBarColor");
            },
            renderRegion: function(a, c) {
                var g, h, i, j, k, l, d = this.values, e = this.options, f = this.target;
                return g = f.pixelHeight, i = b.round(g / 2), j = a * this.totalBarWidth, d[a] < 0 ? (k = i, 
                h = i - 1) : d[a] > 0 ? (k = 0, h = i - 1) : (k = i - 1, h = 2), l = this.calcColor(d[a], a), 
                null !== l ? (c && (l = this.calcHighlightColor(l, e)), f.drawRect(j, k, this.barWidth - 1, h - 1, l, l)) : void 0;
            }
        }), d.fn.sparkline.discrete = A = g(d.fn.sparkline._base, w, {
            type: "discrete",
            init: function(a, e, f, g, h) {
                A._super.init.call(this, a, e, f, g, h), this.regionShapes = {}, this.values = e = d.map(e, Number), 
                this.min = b.min.apply(b, e), this.max = b.max.apply(b, e), this.range = this.max - this.min, 
                this.width = g = "auto" === f.get("width") ? 2 * e.length : this.width, this.interval = b.floor(g / e.length), 
                this.itemWidth = g / e.length, f.get("chartRangeMin") !== c && (f.get("chartRangeClip") || f.get("chartRangeMin") < this.min) && (this.min = f.get("chartRangeMin")), 
                f.get("chartRangeMax") !== c && (f.get("chartRangeClip") || f.get("chartRangeMax") > this.max) && (this.max = f.get("chartRangeMax")), 
                this.initTarget(), this.target && (this.lineHeight = "auto" === f.get("lineHeight") ? b.round(.3 * this.canvasHeight) : f.get("lineHeight"));
            },
            getRegion: function(a, c) {
                return b.floor(c / this.itemWidth);
            },
            getCurrentRegionFields: function() {
                var a = this.currentRegion;
                return {
                    isNull: this.values[a] === c,
                    value: this.values[a],
                    offset: a
                };
            },
            renderRegion: function(a, c) {
                var o, p, q, r, d = this.values, e = this.options, f = this.min, g = this.max, h = this.range, j = this.interval, k = this.target, l = this.canvasHeight, m = this.lineHeight, n = l - m;
                return p = i(d[a], f, g), r = a * j, o = b.round(n - n * ((p - f) / h)), q = e.get(e.get("thresholdColor") && p < e.get("thresholdValue") ? "thresholdColor" : "lineColor"), 
                c && (q = this.calcHighlightColor(q, e)), k.drawLine(r, o, r, o + m, q);
            }
        }), d.fn.sparkline.bullet = B = g(d.fn.sparkline._base, {
            type: "bullet",
            init: function(a, d, e, f, g) {
                var h, i, j;
                B._super.init.call(this, a, d, e, f, g), this.values = d = l(d), j = d.slice(), 
                j[0] = null === j[0] ? j[2] : j[0], j[1] = null === d[1] ? j[2] : j[1], h = b.min.apply(b, d), 
                i = b.max.apply(b, d), h = e.get("base") === c ? 0 > h ? h : 0 : e.get("base"), 
                this.min = h, this.max = i, this.range = i - h, this.shapes = {}, this.valueShapes = {}, 
                this.regiondata = {}, this.width = f = "auto" === e.get("width") ? "4.0em" : f, 
                this.target = this.$el.simpledraw(f, g, e.get("composite")), d.length || (this.disabled = !0), 
                this.initTarget();
            },
            getRegion: function(a, b, d) {
                var e = this.target.getShapeAt(a, b, d);
                return e !== c && this.shapes[e] !== c ? this.shapes[e] : c;
            },
            getCurrentRegionFields: function() {
                var a = this.currentRegion;
                return {
                    fieldkey: a.substr(0, 1),
                    value: this.values[a.substr(1)],
                    region: a
                };
            },
            changeHighlight: function(a) {
                var d, b = this.currentRegion, c = this.valueShapes[b];
                switch (delete this.shapes[c], b.substr(0, 1)) {
                  case "r":
                    d = this.renderRange(b.substr(1), a);
                    break;

                  case "p":
                    d = this.renderPerformance(a);
                    break;

                  case "t":
                    d = this.renderTarget(a);
                }
                this.valueShapes[b] = d.id, this.shapes[d.id] = b, this.target.replaceWithShape(c, d);
            },
            renderRange: function(a, c) {
                var d = this.values[a], e = b.round(this.canvasWidth * ((d - this.min) / this.range)), f = this.options.get("rangeColors")[a - 2];
                return c && (f = this.calcHighlightColor(f, this.options)), this.target.drawRect(0, 0, e - 1, this.canvasHeight - 1, f, f);
            },
            renderPerformance: function(a) {
                var c = this.values[1], d = b.round(this.canvasWidth * ((c - this.min) / this.range)), e = this.options.get("performanceColor");
                return a && (e = this.calcHighlightColor(e, this.options)), this.target.drawRect(0, b.round(.3 * this.canvasHeight), d - 1, b.round(.4 * this.canvasHeight) - 1, e, e);
            },
            renderTarget: function(a) {
                var c = this.values[0], d = b.round(this.canvasWidth * ((c - this.min) / this.range) - this.options.get("targetWidth") / 2), e = b.round(.1 * this.canvasHeight), f = this.canvasHeight - 2 * e, g = this.options.get("targetColor");
                return a && (g = this.calcHighlightColor(g, this.options)), this.target.drawRect(d, e, this.options.get("targetWidth") - 1, f - 1, g, g);
            },
            render: function() {
                var c, d, a = this.values.length, b = this.target;
                if (B._super.render.call(this)) {
                    for (c = 2; a > c; c++) d = this.renderRange(c).append(), this.shapes[d.id] = "r" + c, 
                    this.valueShapes["r" + c] = d.id;
                    null !== this.values[1] && (d = this.renderPerformance().append(), this.shapes[d.id] = "p1", 
                    this.valueShapes.p1 = d.id), null !== this.values[0] && (d = this.renderTarget().append(), 
                    this.shapes[d.id] = "t0", this.valueShapes.t0 = d.id), b.render();
                }
            }
        }), d.fn.sparkline.pie = C = g(d.fn.sparkline._base, {
            type: "pie",
            init: function(a, c, e, f, g) {
                var i, h = 0;
                if (C._super.init.call(this, a, c, e, f, g), this.shapes = {}, this.valueShapes = {}, 
                this.values = c = d.map(c, Number), "auto" === e.get("width") && (this.width = this.height), 
                c.length > 0) for (i = c.length; i--; ) h += c[i];
                this.total = h, this.initTarget(), this.radius = b.floor(b.min(this.canvasWidth, this.canvasHeight) / 2);
            },
            getRegion: function(a, b, d) {
                var e = this.target.getShapeAt(a, b, d);
                return e !== c && this.shapes[e] !== c ? this.shapes[e] : c;
            },
            getCurrentRegionFields: function() {
                var a = this.currentRegion;
                return {
                    isNull: this.values[a] === c,
                    value: this.values[a],
                    percent: this.values[a] / this.total * 100,
                    color: this.options.get("sliceColors")[a % this.options.get("sliceColors").length],
                    offset: a
                };
            },
            changeHighlight: function(a) {
                var b = this.currentRegion, c = this.renderSlice(b, a), d = this.valueShapes[b];
                delete this.shapes[d], this.target.replaceWithShape(d, c), this.valueShapes[b] = c.id, 
                this.shapes[c.id] = b;
            },
            renderSlice: function(a, d) {
                var n, o, p, q, r, e = this.target, f = this.options, g = this.radius, h = f.get("borderWidth"), i = f.get("offset"), j = 2 * b.PI, k = this.values, l = this.total, m = i ? 2 * b.PI * (i / 360) : 0;
                for (q = k.length, p = 0; q > p; p++) {
                    if (n = m, o = m, l > 0 && (o = m + j * (k[p] / l)), a === p) return r = f.get("sliceColors")[p % f.get("sliceColors").length], 
                    d && (r = this.calcHighlightColor(r, f)), e.drawPieSlice(g, g, g - h, n, o, c, r);
                    m = o;
                }
            },
            render: function() {
                var h, i, a = this.target, d = this.values, e = this.options, f = this.radius, g = e.get("borderWidth");
                if (C._super.render.call(this)) {
                    for (g && a.drawCircle(f, f, b.floor(f - g / 2), e.get("borderColor"), c, g).append(), 
                    i = d.length; i--; ) d[i] && (h = this.renderSlice(i).append(), this.valueShapes[i] = h.id, 
                    this.shapes[h.id] = i);
                    a.render();
                }
            }
        }), d.fn.sparkline.box = D = g(d.fn.sparkline._base, {
            type: "box",
            init: function(a, b, c, e, f) {
                D._super.init.call(this, a, b, c, e, f), this.values = d.map(b, Number), this.width = "auto" === c.get("width") ? "4.0em" : e, 
                this.initTarget(), this.values.length || (this.disabled = 1);
            },
            getRegion: function() {
                return 1;
            },
            getCurrentRegionFields: function() {
                var a = [ {
                    field: "lq",
                    value: this.quartiles[0]
                }, {
                    field: "med",
                    value: this.quartiles[1]
                }, {
                    field: "uq",
                    value: this.quartiles[2]
                } ];
                return this.loutlier !== c && a.push({
                    field: "lo",
                    value: this.loutlier
                }), this.routlier !== c && a.push({
                    field: "ro",
                    value: this.routlier
                }), this.lwhisker !== c && a.push({
                    field: "lw",
                    value: this.lwhisker
                }), this.rwhisker !== c && a.push({
                    field: "rw",
                    value: this.rwhisker
                }), a;
            },
            render: function() {
                var m, n, o, p, q, r, s, t, u, v, w, a = this.target, d = this.values, e = d.length, f = this.options, g = this.canvasWidth, h = this.canvasHeight, i = f.get("chartRangeMin") === c ? b.min.apply(b, d) : f.get("chartRangeMin"), k = f.get("chartRangeMax") === c ? b.max.apply(b, d) : f.get("chartRangeMax"), l = 0;
                if (D._super.render.call(this)) {
                    if (f.get("raw")) f.get("showOutliers") && d.length > 5 ? (n = d[0], m = d[1], p = d[2], 
                    q = d[3], r = d[4], s = d[5], t = d[6]) : (m = d[0], p = d[1], q = d[2], r = d[3], 
                    s = d[4]); else if (d.sort(function(a, b) {
                        return a - b;
                    }), p = j(d, 1), q = j(d, 2), r = j(d, 3), o = r - p, f.get("showOutliers")) {
                        for (m = s = c, u = 0; e > u; u++) m === c && d[u] > p - o * f.get("outlierIQR") && (m = d[u]), 
                        d[u] < r + o * f.get("outlierIQR") && (s = d[u]);
                        n = d[0], t = d[e - 1];
                    } else m = d[0], s = d[e - 1];
                    this.quartiles = [ p, q, r ], this.lwhisker = m, this.rwhisker = s, this.loutlier = n, 
                    this.routlier = t, w = g / (k - i + 1), f.get("showOutliers") && (l = b.ceil(f.get("spotRadius")), 
                    g -= 2 * b.ceil(f.get("spotRadius")), w = g / (k - i + 1), m > n && a.drawCircle((n - i) * w + l, h / 2, f.get("spotRadius"), f.get("outlierLineColor"), f.get("outlierFillColor")).append(), 
                    t > s && a.drawCircle((t - i) * w + l, h / 2, f.get("spotRadius"), f.get("outlierLineColor"), f.get("outlierFillColor")).append()), 
                    a.drawRect(b.round((p - i) * w + l), b.round(.1 * h), b.round((r - p) * w), b.round(.8 * h), f.get("boxLineColor"), f.get("boxFillColor")).append(), 
                    a.drawLine(b.round((m - i) * w + l), b.round(h / 2), b.round((p - i) * w + l), b.round(h / 2), f.get("lineColor")).append(), 
                    a.drawLine(b.round((m - i) * w + l), b.round(h / 4), b.round((m - i) * w + l), b.round(h - h / 4), f.get("whiskerColor")).append(), 
                    a.drawLine(b.round((s - i) * w + l), b.round(h / 2), b.round((r - i) * w + l), b.round(h / 2), f.get("lineColor")).append(), 
                    a.drawLine(b.round((s - i) * w + l), b.round(h / 4), b.round((s - i) * w + l), b.round(h - h / 4), f.get("whiskerColor")).append(), 
                    a.drawLine(b.round((q - i) * w + l), b.round(.1 * h), b.round((q - i) * w + l), b.round(.9 * h), f.get("medianColor")).append(), 
                    f.get("target") && (v = b.ceil(f.get("spotRadius")), a.drawLine(b.round((f.get("target") - i) * w + l), b.round(h / 2 - v), b.round((f.get("target") - i) * w + l), b.round(h / 2 + v), f.get("targetColor")).append(), 
                    a.drawLine(b.round((f.get("target") - i) * w + l - v), b.round(h / 2), b.round((f.get("target") - i) * w + l + v), b.round(h / 2), f.get("targetColor")).append()), 
                    a.render();
                }
            }
        }), G = g({
            init: function(a, b, c, d) {
                this.target = a, this.id = b, this.type = c, this.args = d;
            },
            append: function() {
                return this.target.appendShape(this), this;
            }
        }), H = g({
            _pxregex: /(\d+)(px)?\s*$/i,
            init: function(a, b, c) {
                a && (this.width = a, this.height = b, this.target = c, this.lastShapeId = null, 
                c[0] && (c = c[0]), d.data(c, "_jqs_vcanvas", this));
            },
            drawLine: function(a, b, c, d, e, f) {
                return this.drawShape([ [ a, b ], [ c, d ] ], e, f);
            },
            drawShape: function(a, b, c, d) {
                return this._genShape("Shape", [ a, b, c, d ]);
            },
            drawCircle: function(a, b, c, d, e, f) {
                return this._genShape("Circle", [ a, b, c, d, e, f ]);
            },
            drawPieSlice: function(a, b, c, d, e, f, g) {
                return this._genShape("PieSlice", [ a, b, c, d, e, f, g ]);
            },
            drawRect: function(a, b, c, d, e, f) {
                return this._genShape("Rect", [ a, b, c, d, e, f ]);
            },
            getElement: function() {
                return this.canvas;
            },
            getLastShapeId: function() {
                return this.lastShapeId;
            },
            reset: function() {
                alert("reset not implemented");
            },
            _insert: function(a, b) {
                d(b).html(a);
            },
            _calculatePixelDims: function(a, b, c) {
                var e;
                e = this._pxregex.exec(b), this.pixelHeight = e ? e[1] : d(c).height(), e = this._pxregex.exec(a), 
                this.pixelWidth = e ? e[1] : d(c).width();
            },
            _genShape: function(a, b) {
                var c = L++;
                return b.unshift(c), new G(this, c, a, b);
            },
            appendShape: function() {
                alert("appendShape not implemented");
            },
            replaceWithShape: function() {
                alert("replaceWithShape not implemented");
            },
            insertAfterShape: function() {
                alert("insertAfterShape not implemented");
            },
            removeShapeId: function() {
                alert("removeShapeId not implemented");
            },
            getShapeAt: function() {
                alert("getShapeAt not implemented");
            },
            render: function() {
                alert("render not implemented");
            }
        }), I = g(H, {
            init: function(b, e, f, g) {
                I._super.init.call(this, b, e, f), this.canvas = a.createElement("canvas"), f[0] && (f = f[0]), 
                d.data(f, "_jqs_vcanvas", this), d(this.canvas).css({
                    display: "inline-block",
                    width: b,
                    height: e,
                    verticalAlign: "top"
                }), this._insert(this.canvas, f), this._calculatePixelDims(b, e, this.canvas), this.canvas.width = this.pixelWidth, 
                this.canvas.height = this.pixelHeight, this.interact = g, this.shapes = {}, this.shapeseq = [], 
                this.currentTargetShapeId = c, d(this.canvas).css({
                    width: this.pixelWidth,
                    height: this.pixelHeight
                });
            },
            _getContext: function(a, b, d) {
                var e = this.canvas.getContext("2d");
                return a !== c && (e.strokeStyle = a), e.lineWidth = d === c ? 1 : d, b !== c && (e.fillStyle = b), 
                e;
            },
            reset: function() {
                var a = this._getContext();
                a.clearRect(0, 0, this.pixelWidth, this.pixelHeight), this.shapes = {}, this.shapeseq = [], 
                this.currentTargetShapeId = c;
            },
            _drawShape: function(a, b, d, e, f) {
                var h, i, g = this._getContext(d, e, f);
                for (g.beginPath(), g.moveTo(b[0][0] + .5, b[0][1] + .5), h = 1, i = b.length; i > h; h++) g.lineTo(b[h][0] + .5, b[h][1] + .5);
                d !== c && g.stroke(), e !== c && g.fill(), this.targetX !== c && this.targetY !== c && g.isPointInPath(this.targetX, this.targetY) && (this.currentTargetShapeId = a);
            },
            _drawCircle: function(a, d, e, f, g, h, i) {
                var j = this._getContext(g, h, i);
                j.beginPath(), j.arc(d, e, f, 0, 2 * b.PI, !1), this.targetX !== c && this.targetY !== c && j.isPointInPath(this.targetX, this.targetY) && (this.currentTargetShapeId = a), 
                g !== c && j.stroke(), h !== c && j.fill();
            },
            _drawPieSlice: function(a, b, d, e, f, g, h, i) {
                var j = this._getContext(h, i);
                j.beginPath(), j.moveTo(b, d), j.arc(b, d, e, f, g, !1), j.lineTo(b, d), j.closePath(), 
                h !== c && j.stroke(), i && j.fill(), this.targetX !== c && this.targetY !== c && j.isPointInPath(this.targetX, this.targetY) && (this.currentTargetShapeId = a);
            },
            _drawRect: function(a, b, c, d, e, f, g) {
                return this._drawShape(a, [ [ b, c ], [ b + d, c ], [ b + d, c + e ], [ b, c + e ], [ b, c ] ], f, g);
            },
            appendShape: function(a) {
                return this.shapes[a.id] = a, this.shapeseq.push(a.id), this.lastShapeId = a.id, 
                a.id;
            },
            replaceWithShape: function(a, b) {
                var d, c = this.shapeseq;
                for (this.shapes[b.id] = b, d = c.length; d--; ) c[d] == a && (c[d] = b.id);
                delete this.shapes[a];
            },
            replaceWithShapes: function(a, b) {
                var e, f, g, c = this.shapeseq, d = {};
                for (f = a.length; f--; ) d[a[f]] = !0;
                for (f = c.length; f--; ) e = c[f], d[e] && (c.splice(f, 1), delete this.shapes[e], 
                g = f);
                for (f = b.length; f--; ) c.splice(g, 0, b[f].id), this.shapes[b[f].id] = b[f];
            },
            insertAfterShape: function(a, b) {
                var d, c = this.shapeseq;
                for (d = c.length; d--; ) if (c[d] === a) return c.splice(d + 1, 0, b.id), void (this.shapes[b.id] = b);
            },
            removeShapeId: function(a) {
                var c, b = this.shapeseq;
                for (c = b.length; c--; ) if (b[c] === a) {
                    b.splice(c, 1);
                    break;
                }
                delete this.shapes[a];
            },
            getShapeAt: function(a, b, c) {
                return this.targetX = b, this.targetY = c, this.render(), this.currentTargetShapeId;
            },
            render: function() {
                var e, f, g, a = this.shapeseq, b = this.shapes, c = a.length, d = this._getContext();
                for (d.clearRect(0, 0, this.pixelWidth, this.pixelHeight), g = 0; c > g; g++) e = a[g], 
                f = b[e], this["_draw" + f.type].apply(this, f.args);
                this.interact || (this.shapes = {}, this.shapeseq = []);
            }
        }), J = g(H, {
            init: function(b, c, e) {
                var f;
                J._super.init.call(this, b, c, e), e[0] && (e = e[0]), d.data(e, "_jqs_vcanvas", this), 
                this.canvas = a.createElement("span"), d(this.canvas).css({
                    display: "inline-block",
                    position: "relative",
                    overflow: "hidden",
                    width: b,
                    height: c,
                    margin: "0px",
                    padding: "0px",
                    verticalAlign: "top"
                }), this._insert(this.canvas, e), this._calculatePixelDims(b, c, this.canvas), this.canvas.width = this.pixelWidth, 
                this.canvas.height = this.pixelHeight, f = '<v:group coordorigin="0 0" coordsize="' + this.pixelWidth + " " + this.pixelHeight + '" style="position:absolute;top:0;left:0;width:' + this.pixelWidth + "px;height=" + this.pixelHeight + 'px;"></v:group>', 
                this.canvas.insertAdjacentHTML("beforeEnd", f), this.group = d(this.canvas).children()[0], 
                this.rendered = !1, this.prerender = "";
            },
            _drawShape: function(a, b, d, e, f) {
                var h, i, j, k, l, m, n, g = [];
                for (n = 0, m = b.length; m > n; n++) g[n] = "" + b[n][0] + "," + b[n][1];
                return h = g.splice(0, 1), f = f === c ? 1 : f, i = d === c ? ' stroked="false" ' : ' strokeWeight="' + f + 'px" strokeColor="' + d + '" ', 
                j = e === c ? ' filled="false"' : ' fillColor="' + e + '" filled="true" ', k = g[0] === g[g.length - 1] ? "x " : "", 
                l = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + " " + this.pixelHeight + '"  id="jqsshape' + a + '" ' + i + j + ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + "px;width:" + this.pixelWidth + 'px;padding:0px;margin:0px;"  path="m ' + h + " l " + g.join(", ") + " " + k + 'e"> </v:shape>';
            },
            _drawCircle: function(a, b, d, e, f, g, h) {
                var i, j, k;
                return b -= e, d -= e, i = f === c ? ' stroked="false" ' : ' strokeWeight="' + h + 'px" strokeColor="' + f + '" ', 
                j = g === c ? ' filled="false"' : ' fillColor="' + g + '" filled="true" ', k = '<v:oval  id="jqsshape' + a + '" ' + i + j + ' style="position:absolute;top:' + d + "px; left:" + b + "px; width:" + 2 * e + "px; height:" + 2 * e + 'px"></v:oval>';
            },
            _drawPieSlice: function(a, d, e, f, g, h, i, j) {
                var k, l, m, n, o, p, q, r;
                if (g === h) return "";
                if (h - g === 2 * b.PI && (g = 0, h = 2 * b.PI), l = d + b.round(b.cos(g) * f), 
                m = e + b.round(b.sin(g) * f), n = d + b.round(b.cos(h) * f), o = e + b.round(b.sin(h) * f), 
                l === n && m === o) {
                    if (h - g < b.PI) return "";
                    l = n = d + f, m = o = e;
                }
                return l === n && m === o && h - g < b.PI ? "" : (k = [ d - f, e - f, d + f, e + f, l, m, n, o ], 
                p = i === c ? ' stroked="false" ' : ' strokeWeight="1px" strokeColor="' + i + '" ', 
                q = j === c ? ' filled="false"' : ' fillColor="' + j + '" filled="true" ', r = '<v:shape coordorigin="0 0" coordsize="' + this.pixelWidth + " " + this.pixelHeight + '"  id="jqsshape' + a + '" ' + p + q + ' style="position:absolute;left:0px;top:0px;height:' + this.pixelHeight + "px;width:" + this.pixelWidth + 'px;padding:0px;margin:0px;"  path="m ' + d + "," + e + " wa " + k.join(", ") + ' x e"> </v:shape>');
            },
            _drawRect: function(a, b, c, d, e, f, g) {
                return this._drawShape(a, [ [ b, c ], [ b, c + e ], [ b + d, c + e ], [ b + d, c ], [ b, c ] ], f, g);
            },
            reset: function() {
                this.group.innerHTML = "";
            },
            appendShape: function(a) {
                var b = this["_draw" + a.type].apply(this, a.args);
                return this.rendered ? this.group.insertAdjacentHTML("beforeEnd", b) : this.prerender += b, 
                this.lastShapeId = a.id, a.id;
            },
            replaceWithShape: function(a, b) {
                var c = d("#jqsshape" + a), e = this["_draw" + b.type].apply(this, b.args);
                c[0].outerHTML = e;
            },
            replaceWithShapes: function(a, b) {
                var g, c = d("#jqsshape" + a[0]), e = "", f = b.length;
                for (g = 0; f > g; g++) e += this["_draw" + b[g].type].apply(this, b[g].args);
                for (c[0].outerHTML = e, g = 1; g < a.length; g++) d("#jqsshape" + a[g]).remove();
            },
            insertAfterShape: function(a, b) {
                var c = d("#jqsshape" + a), e = this["_draw" + b.type].apply(this, b.args);
                c[0].insertAdjacentHTML("afterEnd", e);
            },
            removeShapeId: function(a) {
                var b = d("#jqsshape" + a);
                this.group.removeChild(b[0]);
            },
            getShapeAt: function(a) {
                var d = a.id.substr(8);
                return d;
            },
            render: function() {
                this.rendered || (this.group.innerHTML = this.prerender, this.rendered = !0);
            }
        });
    });
}(document, Math), function(window) {
    var HAS_HASHCHANGE = function() {
        var doc_mode = window.documentMode;
        return "onhashchange" in window && (void 0 === doc_mode || doc_mode > 7);
    }();
    L.Hash = function(map) {
        this.onHashChange = L.Util.bind(this.onHashChange, this), map && this.init(map);
    }, L.Hash.parseHash = function() {
        var params = getHashParams();
        if ("undefined" != typeof params.zoom || "undefined" != typeof params.lat || "undefined" != typeof params.lon) {
            var zoom = parseInt(params.zoom.values, 10), lat = parseFloat(params.lat.values), lon = parseFloat(params.lon.values);
            return isNaN(zoom) || isNaN(lat) || isNaN(lon) ? !1 : {
                center: new L.LatLng(lat, lon),
                zoom: zoom,
                params: params
            };
        }
        return !1;
    }, L.Hash.formatHash = function(map) {
        var center = map.getCenter(), zoom = map.getZoom(), precision = Math.max(0, Math.ceil(Math.log(zoom) / Math.LN2)), returnObj = {
            zoom: {
                values: zoom,
                comparator: "="
            },
            lat: {
                values: center.lat.toFixed(precision),
                comparator: "="
            },
            lon: {
                values: center.lng.toFixed(precision),
                comparator: "="
            }
        };
        return returnObj;
    }, L.Hash.prototype = {
        map: null,
        lastHash: null,
        parseHash: L.Hash.parseHash,
        formatHash: L.Hash.formatHash,
        init: function(map) {
            this.map = map, this.lastHash = null, this.onHashChange(), this.isListening || this.startListening();
        },
        removeFrom: function() {
            this.changeTimeout && clearTimeout(this.changeTimeout), this.isListening && this.stopListening(), 
            this.map = null;
        },
        onMapMove: function() {
            var hash;
            if (this.movingMap || !this.map._loaded) return !1;
            if (this.parseHash(hash)) {
                hash = getHashParams();
                var newParams = this.formatHash(this.map);
                _.each(newParams, function(val, key) {
                    hash[key].values = val.values, hash[key].comparator = "=";
                }), updateUrlHash(hash);
            } else hash = getHashParams(), _.extend(hash, this.formatHash(this.map)), updateUrlHash(hash);
            this.lastHash = hash;
        },
        movingMap: !1,
        update: function() {
            var hash = getHashParams();
            if (_.isEqual(hash, this.lastHash)) return !1;
            var parsed = this.parseHash(hash);
            parsed ? (this.movingMap = !0, this.map.setView(parsed.center, parsed.zoom), this.movingMap = !1) : this.onMapMove(this.map);
        },
        changeDefer: 200,
        changeTimeout: null,
        onHashChange: function() {
            if (!this.changeTimeout) {
                var that = this;
                this.changeTimeout = setTimeout(function() {
                    that.update(), that.changeTimeout = null;
                }, this.changeDefer);
            }
        },
        isListening: !1,
        hashChangeInterval: null,
        startListening: function() {
            this.map.on("moveend", this.onMapMove, this), HAS_HASHCHANGE ? L.DomEvent.addListener(window, "hashchange", this.onHashChange) : (clearInterval(this.hashChangeInterval), 
            this.hashChangeInterval = setInterval(this.onHashChange, 500)), this.isListening = !0;
        },
        stopListening: function() {
            this.map.off("moveend", this.onMapMove, this), HAS_HASHCHANGE ? L.DomEvent.removeListener(window, "hashchange", this.onHashChange) : clearInterval(this.hashChangeInterval), 
            this.isListening = !1;
        }
    }, L.hash = function(map) {
        return new L.Hash(map);
    }, L.Map.prototype.addHash = function() {
        this._hash = L.hash(this);
    }, L.Map.prototype.removeHash = function() {
        this._hash.removeFrom();
    };
}(window), L.Rrose = L.Popup.extend({
    _initLayout: function() {
        var closeButton, wrapper, prefix = "leaflet-rrose", container = this._container = L.DomUtil.create("div", prefix + " " + this.options.className + " leaflet-zoom-animated");
        this.options.closeButton && (closeButton = this._closeButton = L.DomUtil.create("a", prefix + "-close-button", container), 
        closeButton.href = "#close", closeButton.innerHTML = "&#215;", L.DomEvent.on(closeButton, "click", this._onCloseButtonClick, this));
        var x_bound = 80, y_bound = 80;
        this.options.position = "n";
        var y_diff = y_bound - this._map.latLngToContainerPoint(this._latlng).y;
        y_diff > 0 && (this.options.position = "s");
        var x_diff = this._map.latLngToContainerPoint(this._latlng).x - (this._map.getSize().x - x_bound);
        x_diff > 0 ? this.options.position += "w" : (x_diff = x_bound - this._map.latLngToContainerPoint(this._latlng).x, 
        x_diff > 0 && (this.options.position += "e")), 2 === this.options.position.length && (this.options.position = y_diff > x_diff ? this.options.position.charAt(0) + this.options.position : this.options.position.charAt(1) + this.options.position), 
        /s/.test(this.options.position) ? ("s" === this.options.position ? (this._tipContainer = L.DomUtil.create("div", prefix + "-tip-container", container), 
        wrapper = this._wrapper = L.DomUtil.create("div", prefix + "-content-wrapper", container)) : (this._tipContainer = L.DomUtil.create("div", prefix + "-tip-container " + prefix + "-tip-container-" + this.options.position, container), 
        wrapper = this._wrapper = L.DomUtil.create("div", prefix + "-content-wrapper " + prefix + "-content-wrapper-" + this.options.position, container)), 
        this._tip = L.DomUtil.create("div", prefix + "-tip " + prefix + "-tip-" + this.options.position, this._tipContainer), 
        L.DomEvent.disableClickPropagation(wrapper), this._contentNode = L.DomUtil.create("div", prefix + "-content", wrapper), 
        L.DomEvent.on(this._contentNode, "mousewheel", L.DomEvent.stopPropagation)) : ("n" === this.options.position ? (wrapper = this._wrapper = L.DomUtil.create("div", prefix + "-content-wrapper", container), 
        this._tipContainer = L.DomUtil.create("div", prefix + "-tip-container", container)) : (wrapper = this._wrapper = L.DomUtil.create("div", prefix + "-content-wrapper " + prefix + "-content-wrapper-" + this.options.position, container), 
        this._tipContainer = L.DomUtil.create("div", prefix + "-tip-container " + prefix + "-tip-container-" + this.options.position, container)), 
        L.DomEvent.disableClickPropagation(wrapper), this._contentNode = L.DomUtil.create("div", prefix + "-content", wrapper), 
        L.DomEvent.on(this._contentNode, "mousewheel", L.DomEvent.stopPropagation), this._tip = L.DomUtil.create("div", prefix + "-tip " + prefix + "-tip-" + this.options.position, this._tipContainer));
    },
    _updatePosition: function() {
        var pos = this._map.latLngToLayerPoint(this._latlng), is3d = L.Browser.any3d, offset = this.options.offset;
        is3d && L.DomUtil.setPosition(this._container, pos), this._containerBottom = /s/.test(this.options.position) ? -this._container.offsetHeight + offset.y - (is3d ? 0 : pos.y) : -offset.y - (is3d ? 0 : pos.y), 
        this._containerLeft = /e/.test(this.options.position) ? offset.x + (is3d ? 0 : pos.x) : /w/.test(this.options.position) ? -Math.round(this._containerWidth) + offset.x + (is3d ? 0 : pos.x) : -Math.round(this._containerWidth / 2) + offset.x + (is3d ? 0 : pos.x), 
        this._container.style.bottom = this._containerBottom + "px", this._container.style.left = this._containerLeft + "px";
    }
}), L.Control.MiniMap = L.Control.extend({
    options: {
        position: "bottomright",
        toggleDisplay: !1,
        zoomLevelOffset: -5,
        zoomLevelFixed: !1,
        zoomAnimation: !1,
        autoToggleDisplay: !1,
        width: 150,
        height: 150,
        aimingRectOptions: {
            color: "#ff7800",
            weight: 1,
            clickable: !1
        },
        shadowRectOptions: {
            color: "#000000",
            weight: 1,
            clickable: !1,
            opacity: 0,
            fillOpacity: 0
        }
    },
    hideText: "Hide MiniMap",
    showText: "Show MiniMap",
    initialize: function(layer, options) {
        L.Util.setOptions(this, options), this.options.aimingRectOptions.clickable = !1, 
        this.options.shadowRectOptions.clickable = !1, this._layer = layer;
    },
    onAdd: function(map) {
        return this._mainMap = map, this._container = L.DomUtil.create("div", "leaflet-control-minimap"), 
        this._container.style.width = this.options.width + "px", this._container.style.height = this.options.height + "px", 
        L.DomEvent.disableClickPropagation(this._container), L.DomEvent.on(this._container, "mousewheel", L.DomEvent.stopPropagation), 
        this._miniMap = new L.Map(this._container, {
            attributionControl: !1,
            zoomControl: !1,
            zoomAnimation: this.options.zoomAnimation,
            autoToggleDisplay: this.options.autoToggleDisplay,
            touchZoom: !this.options.zoomLevelFixed,
            scrollWheelZoom: !this.options.zoomLevelFixed,
            doubleClickZoom: !this.options.zoomLevelFixed,
            boxZoom: !this.options.zoomLevelFixed,
            crs: map.options.crs
        }), this._miniMap.addLayer(this._layer), this._mainMapMoving = !1, this._miniMapMoving = !1, 
        this._userToggledDisplay = !1, this._minimized = !1, this.options.toggleDisplay && this._addToggleButton(), 
        this._miniMap.whenReady(L.Util.bind(function() {
            this._aimingRect = L.rectangle(this._mainMap.getBounds(), this.options.aimingRectOptions).addTo(this._miniMap), 
            this._shadowRect = L.rectangle(this._mainMap.getBounds(), this.options.shadowRectOptions).addTo(this._miniMap), 
            this._mainMap.on("moveend", this._onMainMapMoved, this), this._mainMap.on("move", this._onMainMapMoving, this), 
            this._miniMap.on("movestart", this._onMiniMapMoveStarted, this), this._miniMap.on("move", this._onMiniMapMoving, this), 
            this._miniMap.on("moveend", this._onMiniMapMoved, this);
        }, this)), this._container;
    },
    addTo: function(map) {
        return L.Control.prototype.addTo.call(this, map), this._miniMap.setView(this._mainMap.getCenter(), this._decideZoom(!0)), 
        this._setDisplay(this._decideMinimized()), this;
    },
    onRemove: function() {
        this._mainMap.off("moveend", this._onMainMapMoved, this), this._mainMap.off("move", this._onMainMapMoving, this), 
        this._miniMap.off("moveend", this._onMiniMapMoved, this), this._miniMap.removeLayer(this._layer);
    },
    _addToggleButton: function() {
        this._toggleDisplayButton = this.options.toggleDisplay ? this._createButton("", this.hideText, "leaflet-control-minimap-toggle-display", this._container, this._toggleDisplayButtonClicked, this) : void 0;
    },
    _createButton: function(html, title, className, container, fn, context) {
        var link = L.DomUtil.create("a", className, container);
        link.innerHTML = html, link.href = "#", link.title = title;
        var stop = L.DomEvent.stopPropagation;
        return L.DomEvent.on(link, "click", stop).on(link, "mousedown", stop).on(link, "dblclick", stop).on(link, "click", L.DomEvent.preventDefault).on(link, "click", fn, context), 
        link;
    },
    _toggleDisplayButtonClicked: function() {
        this._userToggledDisplay = !0, this._minimized ? (this._restore(), this._toggleDisplayButton.title = this.hideText) : (this._minimize(), 
        this._toggleDisplayButton.title = this.showText);
    },
    _setDisplay: function(minimize) {
        minimize != this._minimized && (this._minimized ? this._restore() : this._minimize());
    },
    _minimize: function() {
        this.options.toggleDisplay ? (this._container.style.width = "19px", this._container.style.height = "19px", 
        this._toggleDisplayButton.className += " minimized") : this._container.style.display = "none", 
        this._minimized = !0;
    },
    _restore: function() {
        this.options.toggleDisplay ? (this._container.style.width = this.options.width + "px", 
        this._container.style.height = this.options.height + "px", this._toggleDisplayButton.className = this._toggleDisplayButton.className.replace(/(?:^|\s)minimized(?!\S)/g, "")) : this._container.style.display = "block", 
        this._minimized = !1;
    },
    _onMainMapMoved: function() {
        this._miniMapMoving ? this._miniMapMoving = !1 : (this._mainMapMoving = !0, this._miniMap.setView(this._mainMap.getCenter(), this._decideZoom(!0)), 
        this._setDisplay(this._decideMinimized())), this._aimingRect.setBounds(this._mainMap.getBounds());
    },
    _onMainMapMoving: function() {
        this._aimingRect.setBounds(this._mainMap.getBounds());
    },
    _onMiniMapMoveStarted: function() {
        var lastAimingRect = this._aimingRect.getBounds(), sw = this._miniMap.latLngToContainerPoint(lastAimingRect.getSouthWest()), ne = this._miniMap.latLngToContainerPoint(lastAimingRect.getNorthEast());
        this._lastAimingRectPosition = {
            sw: sw,
            ne: ne
        };
    },
    _onMiniMapMoving: function() {
        !this._mainMapMoving && this._lastAimingRectPosition && (this._shadowRect.setBounds(new L.LatLngBounds(this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.sw), this._miniMap.containerPointToLatLng(this._lastAimingRectPosition.ne))), 
        this._shadowRect.setStyle({
            opacity: 1,
            fillOpacity: .3
        }));
    },
    _onMiniMapMoved: function() {
        this._mainMapMoving ? this._mainMapMoving = !1 : (this._miniMapMoving = !0, this._mainMap.setView(this._miniMap.getCenter(), this._decideZoom(!1)), 
        this._shadowRect.setStyle({
            opacity: 0,
            fillOpacity: 0
        }));
    },
    _decideZoom: function(fromMaintoMini) {
        if (this.options.zoomLevelFixed) return fromMaintoMini ? this.options.zoomLevelFixed : this._mainMap.getZoom();
        if (fromMaintoMini) return this._mainMap.getZoom() + this.options.zoomLevelOffset;
        var toRet, currentDiff = this._miniMap.getZoom() - this._mainMap.getZoom(), proposedZoom = this._miniMap.getZoom() - this.options.zoomLevelOffset;
        return currentDiff > this.options.zoomLevelOffset && this._mainMap.getZoom() < this._miniMap.getMinZoom() - this.options.zoomLevelOffset ? this._miniMap.getZoom() > this._lastMiniMapZoom ? (toRet = this._mainMap.getZoom() + 1, 
        this._miniMap.setZoom(this._miniMap.getZoom() - 1)) : toRet = this._mainMap.getZoom() : toRet = proposedZoom, 
        this._lastMiniMapZoom = this._miniMap.getZoom(), toRet;
    },
    _decideMinimized: function() {
        return this._userToggledDisplay ? this._minimized : this.options.autoToggleDisplay ? this._mainMap.getBounds().contains(this._miniMap.getBounds()) ? !0 : !1 : this._minimized;
    }
}), L.Map.mergeOptions({
    miniMapControl: !1
}), L.Map.addInitHook(function() {
    this.options.miniMapControl && (this.miniMapControl = new L.Control.MiniMap().addTo(this));
}), L.control.minimap = function(options) {
    return new L.Control.MiniMap(options);
};