{% extends "basestyle/map_layout.html" %}
{% load staticfiles %}

{% block title %}Fair Lending HMDA Visualization Toolkit - {{lender}}{% endblock %}

{% block head_styles %}
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <!-- TODO: MOVE THESE TO GRUNT / BOWER DEPS -->
    <link href='https://api.tiles.mapbox.com/mapbox.js/v2.1.2/mapbox.css' rel='stylesheet' />
    <script src='https://api.tiles.mapbox.com/mapbox.js/v2.1.2/mapbox.js'></script>
    <script type="text/javascript" src="{% static 'mapping/js/map-vendor.min.js' %}"></script>
    <script type="text/javascript" src="{% static 'mapping/js/map.min.js' %}"></script>
    <script src="{% static 'mapping/js/leaflet-hash.js' %}"></script>
    <script type="text/javascript" src="{% static 'mapping/js/map-layout.min.js' %}"></script>
    <link rel="stylesheet" href="{% static 'mapping/css/vendor.css' %}" />

{% endblock %}

{% block head_scripts %}

{% endblock %}

{% block sidebar_content %}

    <div class="map_aside__tabpanels tabpanels">

        {% include 'partial/map_lender_info.html'%}

        {% include 'partial/map_actions.html'%}

    </div>

{% endblock %}


{% block main_content %}
<div id="map-container">
    <div id="map">
    {% include 'partial/map_key.html'%}    
    </div>
</div>


{% endblock %}

{% block foot_scripts %}
    
    <script>

        /* 
          ---- MAPBOX / LEAFLET CODE ----
        */
        
        // Size the map container for the window size
        setMapHeight();
        
        // Our Mapbox public token so we can load all these fun layers
        L.mapbox.accessToken = 'pk.eyJ1IjoiY2ZwYiIsImEiOiJodmtiSk5zIn0.VkCynzmVYcLBxbyHzlvaQw';
        
        // Initialize the map
        var map = L.mapbox.map('map')
        
        // If we have a metro parameter, center the map on this lat / lon
        {% if metro %}
            map.setView(["{{metro.centlat}}", "{{metro.centlon}}"], 11);
        {% else %}
            // Otherwise, somewhere near Chicago for grins
            map.setView([40, -74.50], 11);
        {% endif %}
        
        // Using our modified Leaflet-Hash plugin, check to see if we need to move the map somewhere else.
        var hash = new L.Hash(map),
            hashCheck = hash.parseHash(hash),
            loadParams = getHashParams();

        // If the hash already has parameters, change the view to be those exact coordinates
        if( typeof hashCheck.params != 'undefined') {
            map.setView([hashCheck.params.lat.values, hashCheck.params.lon.values], hashCheck.params.zoom.values );
        }

        // Set our map options after it's been created and centered
        map.options.maxZoom = 12;
        map.options.minZoom = 9;
        map.options.inertia = false;

        // When the user has stopped moving the map, run init, with a slight delay
        map.on('moveend', _.debounce(init, 650) );

        // Initialize all of our layers
        var layers = {
            MBBase: L.mapbox.tileLayer('cfpb.k55b27gd'),
            Base: L.mapbox.tileLayer('cfpb.fi6hia4i'),
            Water: L.mapbox.tileLayer('cfpb.FL_WATER_all_US'),
            Boundaries: L.mapbox.tileLayer('cfpb.FL_BORDERS_all_US'),
            CountyLabels: L.mapbox.tileLayer('cfpb.1mkotj4i'),
            MSALabels: L.mapbox.tileLayer('cfpb.FL_MSA_labels'),
            PctMinority: L.mapbox.tileLayer('cfpb.FL_TRACT_per-min_US'),
            PctHispanic: L.mapbox.tileLayer('cfpb.FL_TRACT_per-hsp_US'),
            PctBlack: L.mapbox.tileLayer('cfpb.FL_TRACT_per-blk_US'),
            PctAsian: L.mapbox.tileLayer('cfpb.FL_TRACT_per-asn_US'),
            PctNonWhite: L.mapbox.tileLayer('cfpb.FL_TRACT_pct_nhwht_US'),
            Centroids: L.layerGroup([])
        };

        // Baselayers are created here and show up in our layer selector on the screen as radio buttons
        var baseLayers = {
            'Mapbox Base': layers.MBBase,
            'Contiguous US': layers.Base
        };

        // Overlay layers show up as checkboxes and can be enabled at the same time using the layer selector
        var overlays = {
            'Water': layers.Water,
            'Boundaries': layers.Boundaries,
            'MSA Labels': layers.MSALabels,
            'Percentage Minority': layers.PctMinority,
            'Percentage Hispanic': layers.PctHispanic,
            'Percentage Black': layers.PctBlack,
            'Percentage Asian': layers.PctAsian,
            'Percentage Non-white': layers.PctNonWhite,
            'County Labels': layers.CountyLabels
        };

        // This array allows us to remove them from the map when a new one is selected (later)
        var minorityLayers = [layers.PctMinority, layers.PctHispanic, layers.PctBlack, layers.PctAsian, layers.PctNonWhite];

        // Add all our primary default layers to the map up front
        layers.Base.addTo(map);
        layers.Water.addTo(map);
        layers.Boundaries.addTo(map);
        layers.CountyLabels.addTo(map);

        // Create a layer for our circles
        layers.Centroids.addTo(map);

        // Add our +/- and layer controls to the top left
        L.control.layers(baseLayers, overlays, {position: 'topleft'}).addTo(map); 
        // Add a mile scale
        L.control.scale().addTo(map);
        
        // Make sure water and boundaries are above everything else
        layers.Water.bringToFront();
        layers.Boundaries.bringToFront();
        layers.CountyLabels.bringToFront();

        // Add the HTML Template key as a key in the top right
        var key = L.control();
        key.onAdd = function() {
            return L.DomUtil.get('key');
        };
        key.setPosition('topright');
        key.addTo(map);

    /* 
      END MAPBOX / LEAFLET CODE
    */

    // When the DOM is loaded, do the following:
    $(document).ready(function(){

        $('.tabs').show();

        $( window ).resize(function() {
            setMapHeight();
        });

        // When minority changes, redraw the circles with appropriate styles
        $('#category-selector').on('change', function(e) {
            val = $('#category-selector').val();
            layerUpdate(val);  
        });

        // Check to see if we have any parameters for category-selector
        if( typeof loadParams.category != 'undefined'){
            $('#category-selector').val( loadParams.category.values );
            layerUpdate( loadParams.category.values );
        } else {
            addParam( 'category', 'inv_non_hisp_white_only_perc' );
            layerUpdate( 'inv_non_hisp_white_only_perc' );
        }

        // Check to see if we have any parameters for action-taken
        if( typeof loadParams.action != 'undefined'){
            $('#action-taken-selector').val( loadParams.action.values );
        } else {
            addParam( 'action', 'all-apps-5' );
        }

        // When the user changes the action taken data selector, re-initialize
        $('#action-taken-selector').on('change', function(){
            init();
            addParam( 'action', $('#action-taken-selector option:selected').val() );
        })


        //Let the application do its thing 
        init();
        
    });
    
    // Go get the tract centroids and supporting data, THEN build a data object (uses jQuery Deferreds)
    function init(){
        $.when( getTractsInBounds( getBoundParams() ), getTractData( getBoundParams(), getActionTaken( $('#action-taken-selector option:selected').val() ))).done( function(data1, data2){
            rawGeo = data1[0];
            rawData = data2[0];
            createTractDataObj(); 
            redrawCircles(dataStore.tracts);
            $('#bubbles_loading').hide();
        });
    }

    // Supporting function to adjust the leaflet map to the height of the window
    function setMapHeight() {
        /* Set the map div to the height of the browser window minus the header. */
        var viewportHeight = $(window).height();
        var warningBannerHeight = $('#warning-banner').outerHeight();
        var headerHeight = $('#header').outerHeight();
        var mapHeaderHeight = $('#map-header').outerHeight();
        var mapHeight = (viewportHeight - (warningBannerHeight + headerHeight + mapHeaderHeight));
        $('#map-aside').css('height', mapHeight);
        $('#map').css('height', mapHeight);
    }


    /* 
        ---- GET DATA SCRIPTS ----
    */    

    var rawGeo, rawLar, rawMinority, rawData,
    dataStore = {};
    dataStore.tracts = {};
    
    function getTractsInBounds( bounds, callback ){
        //TODO: Modify parameters for this endpoint to take param hooks instead of forward slash

        $('#bubbles_loading').show();

        // Create the appropriate URL path to return values
        var endpoint = '/api/tractCentroids/', 
            params = { neLat: bounds.neLat,
                       neLon: bounds.neLon,
                       swLat: bounds.swLat,
                       swLon: bounds.swLon };
        return $.ajax({
            url: endpoint, data: params, traditional: true,
            success: console.log('tract Get successful')
        }).fail( function( status ){
            console.log( 'no data was available at' + endpoint + '. status: ' + status );
        });

        if( typeof callback === 'function' && callback() ){
            callback;
        }

    }    

    function getTractData( bounds, actionTakenVal, callback ){
        $('#bubbles_loading').show();
        var endpoint = '/api/all/',
            params = { year: 2013,
                        neLat: bounds.neLat,
                        neLon: bounds.neLon,
                        swLat: bounds.swLat,
                        swLon: bounds.swLon };

        // Check to see if another year has been requested other than the default
        if ( urlParam('year') ){
            params.year = urlParam('year');
        }

        // Set the lender parameter based on the current URL param
        if ( urlParam('lender') ){
            params['lender'] = urlParam('lender');
        } else {
            console.log(' Lender parameter is required.');
            return false;
        }

        // If actionTaken, go get data, otherwise
        // let the user know about the default value
        if ( actionTakenVal ) {
            params['action_taken'] = actionTakenVal;
        } else {
            console.log('No action taken value - default (1-5) will be used.');
        }

        return $.ajax({
            url: endpoint, data: params, traditional: true,
            success: console.log('get API All Data request successful')
        }).fail( function( status ){
            console.log( 'no data was available at' + endpoint + '. status: ' + status );
        });;

        if( typeof callback === 'function' && callback() ){
            callback;
        }
    }

    function createTractDataObj( callback ){
        dataStore.tracts = {};

        // For each top-level data element returned (minority, loanVolume)
        _.each( rawGeo.features, function(feature, key){
            // Loop through each tract and merge the dataset (this could be done server side as well if faster)
            // Make sure the tracts object exists before writing to it.
            var geoid = feature.properties.geoid;
            dataStore.tracts[geoid] = feature.properties;
            _.extend( dataStore.tracts[geoid], rawData.minority[geoid] );

            if( typeof rawData.loanVolume[geoid] != 'undefined'){
                _.extend( dataStore.tracts[geoid], rawData.loanVolume[geoid] );
            } else {
                dataStore.tracts[geoid].volume = 0;
            }

        });

        if( typeof callback === 'function' && callback() ){
            callback;
        }
    }

  
    /*
        END GET DATA SECTION
    */

    /* 
        ---- DRAW CIRCLES ----
    */

    function redrawCircles( geoData ){
        // Remove circles currently on the page (TODO: Add as LayerGroup and transition)
        $('#bubbles_loading').show();
        layers.Centroids.clearLayers();
        _.each(geoData, function(geo) {
            var bubble = drawCircle(geo);
        });
    }

    function updateCircles(){
        //TODO: Figure out best way to update colors of existing, not redraw to reduce lag
        layers.Centroids.eachLayer( function(layer){
            layer.setStyle({fillColor: updateMinorityCircleFill(layer.geoid) });
        });
        console.log("color update complete.");
    }


    function drawCircle(geo){
        var data = geo,
            style = minorityContinuousStyle(
               geo, baseStyle),
            circle = L.circle([geo.centlat, geo.centlon],
                              hmdaStat(data), style );
        //  We will use the geoid when redrawing
        circle.geoid = geo.geoid;
        circle.on('mouseover mousemove', function(e){
            new L.Rrose({ offset: new L.Point(0,0), closeButton: false, autoPan: false })
              .setContent(data['volume'] + ' records<br />' + data['num_households'] + ' households')
              .setLatLng(e.latlng)
              .openOn(map);
        });
        circle.on('mouseout', function(){ 
            map.closePopup();
        });
        layers.Centroids.addLayer(circle);

    }

    /*
        END DRAW CIRCLES SECTION
    */

    /*
        ---- STYLE THE CIRCLES BASED ON MINORITY ----
    */

    var baseStyle = { fillOpacity: 0.9, weight: 0.5, className: 'lar-circle', fillColor: '#333' };
    
    //  population-less tracts
    var noStyle = {stroke: false, weight: 0, fill: false};
    
    function minorityContinuousStyle(geoProps, baseStyle) {
        return minorityStyle(
            geoProps, 
            function(minorityPercent, bucket) {
                return (minorityPercent - bucket.lowerBound) / bucket.span;
            },
            baseStyle
        );
    }

    //  Shared function for minority styling; called by the two previous fns
    function minorityStyle(geoProps, percentFn, baseStyle) {
        var geoid = geoProps.geoid,
            tract = dataStore.tracts[geoid];
        // Different styles for when the tract has zero pop, or
        // we have percentages of minorities
        if (tract['total_pop'] === 0 || tract.volume === 0 ) {
            return noStyle;
        } else {
            var perc = minorityPercent(tract),
                bucket = toBucket(perc),
                // convert given percentage to percents within bucket's bounds
                bucketPercent = percentFn(perc, bucket);
            return $.extend({}, baseStyle, {
                fillColor: colorFromPercent(bucketPercent,
                                           bucket.colors)
            });
        }
    }

    // This function returns only the fill color after a minority is changed.
    function updateMinorityCircleFill(geoid){
        var tract = dataStore.tracts[geoid];
        // Different styles for when the tract has zero pop, or
        // we have percentages of minorities
        if (tract['total_pop'] === 0 || tract.volume === 0 ){
            return noStyle;
        } else {
            var perc = minorityPercent(tract),
                bucket = toBucket(perc),
                // convert given percentage to percents within bucket's bounds
                bucketPercent = percentFn(perc, bucket);
            return colorFromPercent(bucketPercent, bucket.colors);
        }    
    }

    function percentFn(minorityPercent, bucket) {
                return (minorityPercent - bucket.lowerBound) / bucket.span;
    }

    //  Using the selector, determine which statistic to display.
    function minorityPercent(tractData) {
        var fieldName = $('#category-selector option:selected').val();
        if (fieldName.substring(0, 4) === 'inv_') {
            return 1 - tractData[fieldName.substr(4)];
        } else {
            return tractData[fieldName];
        }
    }

    var colorRanges = [
        {
            span: 0.5,
            lowerBound: 0,
            colors: {
                lowR: 107,
                lowG: 40,
                lowB: 10,
                highR: 250,
                highG: 186,
                highB: 106
            }
        },
        {
            span: 0.5,
            lowerBound: 0.5,
            colors: {
                lowR: 124,
                lowG: 198,
                lowB: 186,
                highR: 12,
                highG: 48,
                highB: 97
            }
        }
    ]

    function toBucket(percent) {
        var i,
            len = colorRanges.length;
        for (i = 0; i < len - 1; i++) {
            //  Next bucket is too far
            if (colorRanges[i + 1].lowerBound > percent) {
                return colorRanges[i];
            }
        } 
        return colorRanges[len - 1];  //  last color
    };

    /* Given low and high colors and a percent, figure out the RGB of said
     * percent in that scale */
    function colorFromPercent(percent, c) {
        var diffR = (c.highR - c.lowR) * percent,
            diffG = (c.highG - c.lowG) * percent,
            diffB = (c.highB - c.lowB) * percent;
        return 'rgb(' + (c.lowR + diffR).toFixed() + ', ' +
               (c.lowG + diffG).toFixed() + ', ' +
               (c.lowB + diffB).toFixed() + ')';
    }

    /*
        END STYLE SECTION
    */

    /* 
        ---- UTILITY FUNCTIONS ----

    */

    //Scales statistical data to the appropriate level
    function hmdaStat(tractData) {
        var $selected = $('#action-taken-selector option:selected'),
            fieldName = $selected.val(),
            scale = $selected.data('scale'),
            area = scale * tractData['volume'];
        //  As Pi is just a constant scalar, we can ignore it in this
        //  calculation: a = pi*r*r   or r = sqrt(a/pi)
            return Math.sqrt(area);
    }

    // Helper that ensures when a new layer is selected, all others are hidden and primaries stay up front
    function layerUpdate( layer ){
        if ( !layer ){
            console.log('The layer you\'ve requested does not exist.');
        }
        for (var i = minorityLayers.length - 1; i >= 0; i--) {
            map.removeLayer(minorityLayers[i]);
        };
        switch( layer ){
            case 'inv_non_hisp_white_only_perc':
                layer = layers.PctMinority;
                break;
            case 'hispanic_perc':
                layer = layers.PctHispanic;
                break;
            case 'non_hisp_black_only_perc':
                layer = layers.PctBlack;
                break;
            case 'non_hisp_asian_only_perc':
                layer = layers.PctAsian;
                break;
            case 'non_hisp_white_only_perc':
                layer = layers.PctNonWhite;
                break;
        }
        map.addLayer( layer );
        layers.Water.bringToFront();
        layers.Boundaries.bringToFront();
        layers.CountyLabels.bringToFront();
        addParam( 'category', $('#category-selector option:selected').val() );
        addParam( 'action', $('#action-taken-selector option:selected').val() );
        updateCircles();
    }

    // Gets non-hash URL parameters
    function urlParam(field) {
        var url = window.location.search.replace('?', ''),
            keyValueStrs = url.split('&'),
            pairs = _.map(keyValueStrs, function(keyValueStr) {
                return keyValueStr.split('=');
            }),
            params = _.reduce(pairs, function(soFar, pair) {
                if (pair.length === 2) {
                    soFar[pair[0]] = pair[1];
                }
                return soFar;
            }, {});
        return params[field];
    }

    // Parameter helper function that filters the query according to dropdown values
    function getActionTaken( value ){
        var actionTaken;

        switch (value) {
            case 'all-apps-5': 
                actionTaken = '1,2,3,4,5';
                break; 
            case 'all-apps-6': 
                actionTaken = '1,2,3,4,5,6';
                break; 
            case 'originations-1': 
                actionTaken = '1';
                break; 
        }
        return actionTaken;
    }

    // Simple function to return bounds consistently with our padding / fixed #
    function getBoundParams(){
        var bounds = map.getBounds();
        padding = .00;
        console.log(bounds);
        return { neLat: (bounds._northEast.lat + padding).toFixed(6),
                neLon: (bounds._northEast.lng + padding).toFixed(6),
                swLat: (bounds._southWest.lat - padding).toFixed(6),
                swLon: (bounds._southWest.lng - padding).toFixed(6)
            }
    }

    function getUniques( arr ){
        return _.uniq( arr );
    }

    /* 
        END UTILITY FUNCTIONS
    */

        
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/underscore.js/1.6.0/underscore-min.js"></script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/typeahead.js/0.10.2/typeahead.bundle.min.js"></script>
    <script type="text/javascript" src="{% static 'mapping/js/metro-search.js' %}"></script>

{% endblock %}
